Ссылка на документацию vs методическая поддержка и курсы:{
	В 1С есть огромная встроенная справка, которую стоит почитать.
	
	https://its.1c.ru/db/metod8dev		Методическая поддержка для разработчиков и администраторов 1С:Предприятия 8
	https://its.1c.ru/db/v838doc		1С:Предприятие 8.3.8. Документация
	
	https://its.1c.ru/section/books     Книги и переодика:
			https://its.1c.ru/db/pubcomplexreports	книга разработка сложных отчетов
			https://its.1c.ru/db/pubqlang		Е. Ю. Хрусталева-Язык запросов «1С:Предприятия 8»
	
	/*close*/Интуит по платформе{
			//Бессмысленно, пока не прочитаю док и документацию с парой книг, не буду трогать. Лучше в бух загляну.
		/*3953*/Основы конфигурирования в системе "1С:Предприятие 8.0" //https://www.intuit.ru/studies/courses/86/86/info
		/*1420*/Основы разработки для платформы 1С:Предприятие 8.2 в режиме "Управляемое приложение" //https://www.intuit.ru/studies/courses/2318/618/info
		/*1942*/Основы разработки прикладных решений для 1С:Предприятие 8.1 //https://www.intuit.ru/studies/courses/617/473/info
		/*?*/НИУ ВШЭ (Высшая Школа Бизнес-Информатики): Разработка прикладных решений для платформы "1С:Предприятие 8.1": Разработка прикладных решений для платформ "1С:Предприятие 8.1" //https://www.intuit.ru/studies/professional_skill_improvements/17640/courses/548/info
		!!!have moment logical && algorithm/*533*/Разработка прикладных решений для платформы 1С:Предприятие 8.2 в режиме "Управляемое приложение" //https://www.intuit.ru/studies/courses/2321/621/info
	}//EndRegion "Интуит по платформе"
	
	/*11005|1472*/Практика бухгалтерского учета в 1С:Бухгалтерии 8 //https://www.intuit.ru/studies/courses/581/437/info
	/*15479|2174*/1С:Бухгалтерия 2.0: начало работы //https://www.intuit.ru/studies/courses/2328/628/info 
	/*3429|574*/1С:Бухгалтерия 2.0: особенности учетных работ //https://www.intuit.ru/studies/courses/2329/629/info
	/*10413|2552*/1С:Бухгалтерия 8.1 //https://www.intuit.ru/studies/courses/2333/633/info
}

Содержание документации:{
	Руководство разработчика{
		Руководство разработчика
		+	Введение
		+	Глава 1. Концепция системы
		+	Глава 2. Работа с конфигурацией
		+	Глава 3. Интерфейс приложения
		+	Глава 4. Встроенный язык
		+	Глава 5. Объекты конфигурации
		+	Глава 6. Командный интерфейс
		+	Глава 7. Формы
		+	Глава 8. Работа с запросами
		+	Глава 9. Работа с данными //блокировки
		+	Глава 10. Система компоновки данных
		Глава 11. Бухгалтерский учет
		Глава 12. Периодические расчеты
		Глава 13. Бизнес-процессы и задачи
		-	Глава 14. Анализ данных и прогнозирование
		Глава 15. Механизмы обмена данными
		Глава 16. Работа с различными форматами данных
		Глава 17. Механизмы интернет-сервисов
		Глава 18. Механизм заданий
		Глава 19. Механизм полнотекстового поиска в данных
		Глава 20. Механизм временного хранилища, работа с файлами и картинками
		Глава 21. Журнал регистрации
		Глава 22. Механизм криптографии
		Глава 23. Внешние источники данных
		Глава 24. Механизм разделения данных
		Глава 25. История данных
		Глава 26. Разработка решений для мобильной платформы
		Глава 27. Система взаимодействия
		Глава 28. Инструменты разработки
		Глава 29. Отладка и тестирование прикладных решений
		Глава 30. Механизм сравнения и объединения конфигураций
		Глава 31. Групповая разработка конфигурации
		Глава 32. Поставка и поддержка конфигурации
		Глава 33. Расширение конфигурации
		Глава 34. Сервисные возможности
		Глава 35. Внешние компоненты
		Глава 36. Особенности разработки кроссплатформенных прикладных решений
		Приложение 1. Конвертация информационных баз системы «1С:Предприятие 7.7»
		Приложение 2. Форматы навигационных ссылок
		Приложение 3. Правила формирования текстов стандартных команд и автоматических заголовков форм
		Приложение 4. Перечень автоматически сохраняемых настроек
		Приложение 5. Поисковые выражения полнотекстового поиска
		Приложение 6. Описание прав доступа
		Приложение 7. Особенности поведения системы в различных режимах
		Приложение 8. Особенности работы с различными СУБД
		Приложение 9. Работа с XBase
		Приложение 10. Особенности использования отдельных механизмов
		Приложение 11. Правила автоматического формирования имен элементов формы
		Приложение 12. Описание сущностей, предоставляемых через стандартный интерфейс OData
		Приложение 13. Префиксы пространств имен при JSON-сериализации
}	
	Руководство администратора{
		Руководство администратора
		Введение
		Глава 1. Требования к аппаратуре и программному обеспечению
		Глава 2. Установка системы «1С:Предприятие»
		Глава 3. Установка конфигураций
		Глава 4. Запуск компонентов системы
		Глава 5. Ведение списка информационных баз
		Глава 6. Администрирование информационной базы
		Глава 7. Настройка веб-серверов для работы с «1С:Предприятием»
		Глава 8. Настройка веб-браузеров для работы в веб-клиенте
		Глава 9. Защита от несанкционированного использования: особенности и настройка
		Глава 10. Обновление системы
		Глава 11. Удаление системы
		Глава 12. Администрирование мобильной платформы
		Приложение 1. Структура каталога установки и назначение каталогов и файлов
		Приложение 2. Описание элементов журнала регистрации
		Приложение 3. Описание и расположение служебных файлов
		Приложение 4. Вспомогательные утилиты
		Приложение 5. Обработка ошибок
		Приложение 6. Интернет-сервисы получения списка общих информационных баз и дистрибутива клиентского приложения
		Приложение 7. Параметры командной строки запуска «1С:Предприятия»
		Приложение 8. Используемые компоненты и материалы
}
	Клиент-серверный вариант. Руководство администратора{
		Клиент-серверный вариант. Руководство администратора
		Введение
		Глава 1. Требования к аппаратуре и программному обеспечению
		Глава 2. Клиент-серверный вариант работы
		Глава 3. Установка компонентов системы
		Глава 4. Запуск компонентов системы
		Глава 5. Администрирование
		Глава 6. Удаление системы
		Приложение 1. Формат строки описания лицензии
	}
	Руководство пользователя{
		+	Руководство пользователя
		+	Введение
		+	Глава 1. О системе
		+	Глава 2. Установка и обновление системы
		+	Глава 3. Начало работы
		+	Глава 4. Интерфейс системы
		Глава 5. Работа в формах
		Глава 6. Списки
		Глава 7. Работа с данными различных видов
		Глава 8. Отчеты
		Глава 9. Изменение варианта отчета
		Глава 10. Сервисные возможности
		Глава 11. Настройка программы
		Глава 12. Получение справочной информации
		Глава 13. Формат поисковых выражений
		Глава 14. Работа с веб-клиентом
		Глава 15. Режим низкой скорости соединения
		Глава 16. Режим обычного приложения
		Приложение 1. Язык выражений системы компоновки данных
		Приложение 2. Текстовый редактор
		Приложение 3. Редактор табличных документов
		Приложение 4. Редактор HTML-документов
		Приложение 5. Редактор графической схемы
		Приложение 6. Редактор географической схемы
}
	Руководство пользователя. Интерфейс «Такси»{
		Руководство пользователя. Интерфейс «Такси»
		Введение
		Глава 1. Интерфейс «Такси»
		Глава 2. Работа в формах
		Глава 3. Списки
		Глава 4. Работа с данными различных видов
		Глава 5. Отчеты
		Глава 6. Изменение варианта отчета
		Глава 7. Система взаимодействия
		Глава 8. Сервисные возможности
		Глава 9. Настройка программы
		Глава 10. Получение справочной информации
		Глава 11. Формат поисковых выражений
	}
}//EndRegion "Содержание документации"

remarks{
Встроенный язык является предметно-ориентированным.
система автоматизации учета
ИТС – информационно-технологическое сопровождение
справочная правовая система «Гарант»
1С для разработки прикладных решений -для автоматизации самых разных участков экономической деятельности предприятия
Функционирование системы делится на два процесса – разработка (описание модели предметной области средствами системы) и исполнение (обработка данных предметной области).
Результатом разработки является программный продукт (конфигурация), который представляет собой модель предметной области.

Книга и PostGreSql{
Ссылка на скачивание версии.
https://postgrespro.ru/products/1c/supported
Основная страница про версии:
https://postgrespro.ru/products/1c_build

А. Ю. Васильев -Работа с PostgreSQL: настройка и масштабирование
стр 11 из 288

Зарегистрируется службу "postgrespro-X64-10" она будет запускаться автоматически при старте компьютера.

https://postgrespro.ru/media/2018/01/10/introbook_v4.pdf это книга, основное руководство.
Е.В. Филиппов Настольная книга 1С:Эксперта по технологическим вопросам.
стр 16\313
Задачи и оценка:
	1-Быстродействие системы. Анализ аппаратных и программных средств, поиск узких мест. Рекомендации по увеличению быстродействия.
	2-Степень соответствия программного кода стандартам "1С". Возможно, дать рекомандации по исправлению, с расчетом стоимости работ.
	3-Степень востребованности доработок функционала в системе.
	4-Оптимальность реализации написанного функционала с точки зрения методологии (оптимальность бизнес-процессов) и с точки зрения программирования. Дать рекомандации по оптимизации.

MS SQL умеет делать дифференциальное резервное копирование, а PostgreSQL нет. PostgreSQL делает только полный backup.
PostgreSQL не имеет средств валидации файлов backup. Сняв backup и нельзя узнать можно ли из него восстановиться.
курс эксперта Виктора Богачева // Видео-кейс от Виктора Богачева вроде рассказывает о эксперт по высоконагруженным системам и тестировании.
postgresql для 1с windows 10

PostgreSQL имеются следующие ограничения:
Максимальный размер базы данных		- Нет ограничений
Максимальный размер таблицы			- 32 Тбайт
Максимальный размер записи			- 1,6 Тбайт
Максимальный размер поля			- 1 Гбайт
Максимум записей в таблице			- Нет ограничений
Максимум полей в записи 			- 250—1600, в зависимости от типов полей
Максимум индексов в таблице			- Нет ограничений
}

Список зарегистрированных информационных баз хранится в файле на локальном компьютере в каталоге "\Application Data\1C\1Cv8" текущего пользователя и имеет имя "v8ib.lst". Файл представляет собой текстовый документ в кодировке UTF-8 и состоит из секций. Каждая секция описывает одну информационную базу.

Впроцессе работы системы 1С:Предприятие 8.0 могут возникать различные внештатные ситуации - отключение питания компьютера, зависание операционной системы, сбои оборудования и пр. Такие ситуации, возникшие в процессе записи изменений в информационную базу системы 1С:Предприятие, могут привести к ее некорректному состоянию. Процедура "Тестирование и исправление информационной базы" предназначена для диагностики и устранения ошибочных состояний информационных баз.
 
Утилита администрирования клиент-серверного варианта предназначена для решения следующих задач:
	мониторинг серверов 1С:Предприятия;
	просмотр списка информационных баз;
	создание и удаление информационных баз;
	мониторинг соединений пользователей с информационными базами;
	отключение пользователей от информационной базы.
	
Запуск из командной строки{
Все параметры подробно рассмотрены в "Руководстве по установке и запуску" 1С:Предприятия 8.0.
Для выполнения административной установки необходимо запус¬тить программу установки setup.exe с ключом /а. 
После запуска на экран выводится диалог, в котором необходимо указать каталог административной установки. В указанном каталоге будет создан набор файлов, необходимый для установки на локальных рабочих местах. Для установки системы 1С:Предприятие 8.0 на локальных рабо¬чих местах необходимо запустить программу setup.exe из каталога административной установки.
Параметры командной строки выбора режима:
CONFIG	запуск системы 1С:Предприятие 8.0 в режиме «Конфигуратор»;  
ENTERPRISE	запуск системы 1С:Предприятие 8.0 в режиме «1С:Предприятие»; 
'CREATEINFOBASE	<connect string>	[/AddlnList [<имя  ИБ>] ]	создание информационной базы
		<connect string>	строка, задающая параметры информационной базы, каждый из которых представляет собой фрагмент вида <Имя параметра=хЗначениё>, где Имя параметра — имя параметра, а Значение — его значение. Фрагменты отделяются друг от друга символами ';'. Если значение содержит пробельные символы, то оно должно быть заключено в двойные кавычки (").
		Для файлового варианта определен параметр:
			File — каталог информа¬ционной базы;
			Locale — язык (страна), которые будут исполь¬зованы при создании информационной базы. Допустимые значения такие же как у параметра <Форматная строка> метода Формат. Параметр Locale задавать не обязательно. Если не задан, то будут использованы региональные установки текущей информационной базы.
		Для клиент-серверного вари¬анта определены параметры:
			Srvr —имя сервера 1С:Предприятия; 
			Ref — имя информацион¬ной базы на сервере;
			SQLSrvr — имя SQL серве¬ра;
			SQLDB — имя SQL базы дан¬ных;
			SQLUTD — имя пользователя SQL;
			SQLPwd — пароль пользова¬теля SQL. Если пароль для пользователя SQL не за¬дан, то данный параметр можно не указывать
			SQLYOf f s - смещение дат, используемое для хранения дат в SQL Server. Может принимать значения 0 или 2000. Данный параметр задавать не обязательно. Если не задан принимается значение 0.
			Locale — язык (страна), (аналогично файловому варианту).
		Для всех вариантов определены параметры:
			Usr — имя пользователя; Pwd — пароль 
/AddlnList	параметр, показывающий, под каким именем добавлять базу в список, если не указан, база не будет добавлена в список. Если не указано имя, используется умолчание, аналогичное интеменения Windows-аутентификации при старте 1С:Предприятия или Конфи¬гуратора. Если ключ /WA не указывается, то подразумева¬ется, что используется пара¬метр командной строки /WA+ 
/AU-		запрет вывода вопроса об обновлении текущей версии 1С:Предприятия с административной установки 
/AU+ 	установка вывода вопроса об обновлении текущей версии 1С:Предприятия с админист-ративной установки. Если ключ /AU не указывается, то подразумевается, что исполь-зуется параметр командной строки /AU+ 
/Out<Имя файла> [-NoTruncate] 	установка файла для вывода служебных сообщений. Если задан ключ -NoTruncate (через пробел), файл не очищается 
/L<Ka талог> 	указывается каталог локализованных ресурсов интерфейса (например, «RU») 
/DisableStartupMessages 	Подавляет стартовые сообщения: «Конфигурация базы данных не соответствует сохраненной конфигурации. Продолжить?»; «Возможностей Вашего компьютера недостаточно для редактирования справки по конфигурации. Для редакти¬рования справки необходимо установить Microsoft Internet 
/@<имя файла> 	параметры командной строки записаны в указанном файле 
/Р<Дуть> 	путь к информационной базе, если она хранится в файле (имя файла указывать не на¬до) 
/S<Адрес> 	адрес информационной базы, хранящейся на сервере 1С:Предприятия 8.0, складывается следующим образом:
		<Имя компьютера, работающего сервером приложений>\ < Ссылочное имя информационной базы, известное в рамках сервера 1C:Предприятия 8.0> 
/N<Имя> 	имя пользователя. Должно быть указано так же, как в списке пользователей, создаваемом в Конфигураторе 
/Р<Пароль> 	пароль пользователя, имя которого указано в параметре /N. Если у пользователя нет пароля, этот параметр можно опустить 
/WA- 	запрет применения Windows-аутентификации при старте Предприятия или Конфигура¬тора 
/С< Строка текста> 	передача параметра в конфигурацию 
 
Параметры командной строки пакетного режима конфигуратора:
	/DumpIB<-Имя файла> 	выгрузка информационной базы в командном режиме 
	/RestoreIB<J<fMJT файла> 	загрузка информационной базы в командном режиме 
	/DumpCfg<имя cf файла> 	сохранение конфигурации в файл 
	/LoadCfg<имя cf файла> 	загрузка конфигурации из файла 
	/UpdateDBCfg [-WarningsAsErrors] 	обновление конфигурации базы данных. Если ключ WarningsAsErrors указан (через пробел), то все предупредительные сообщения будут трактоваться как ошибки 
	/DumpDBCfg<HMH cf файла> 	сохранение конфигурации базы данных в файл 
	/RollbackCfg 	возврат к конфигурации базы данных 
	/CheckModules 	выполнить синтаксический контроль 
	/UpdateCfg<HMH cf|cfu файла> 	обновление конфигурации, находящейся на поддержке 
	/IBCheckAndRepair [-Relndex] [-Loglntergrity -LogAndRefsIntergrity] [-RecalcTotals] [-IBCompression] [-TestOnly | [-BadRefCreate | -BadRefClear | -BadRefNone] [-BadDataCreate -BadDataDelete] ] 	выполнить тестирование и исправление информационной базы 
	Relndex 	переиндексация таблиц 
	Loglntergrity 	проверка логической целост¬ности 
	LogAndRefsIntergrity 	проверка логической и ссы¬лочной целостности 
	RecalcTotals 	пересчет итогов 
	IBCompression 	сжатие таблиц 
	TestOnly 	только тестирование 
	BadRefCreate 	создавать объекты 	 
	BadRefClear 	очищать объекты 	 
	BadRefNone 	не изменять 	 
					

	При частичной потере объектов:
	BadDataCreate 	создавать объекты 
	BadDataDelete 	удалять объекты 

	Одновременное использование ключей внутри подгруппы пара¬метров не допускается.
	/CheckConfig [-ClientServer] [-Client ] [- ExternalConnectionServer] [ - ExternalConnection] 	выполнить централизованный механизм проверки конфигу¬рации 

	при наличии ссылок на несуществующие объекты:
	[-Server] [-DistributiveModules] [-IncorrectReferences] [ - ConfigLogicallntegrity ] [-UnreferenceProcedures] [-HandlersExistence] [ - Empty Handlers] 	 	 
	ClientServer 	проверка работы клиентского приложения. Проверка ком¬пиляции модулей в режиме эмуляции среды клиентского приложения, выполняемого в файловом режиме. 	 
	Client 	проверка работы клиентского приложения в режиме кли¬ент-сервер. Проверка компи-ляции модулей в режиме эму¬ляции среды клиентского приложения, выполняемого в режиме клиент-сервер. 	 
	ExternalConnectionServer 	проверка работы внешнего соединения, Проверка компи¬ляции модулей в режиме эму¬ляции среды внешнего соеди¬нения, выполняемого в файловом режиме. 	 
	ExternalConnection 	проверка работы внешнего соединения в режиме клиент-сервер. Проверка компиляции модулей в режиме эмуляции среды внешнего соединения, выполняемого в режиме кли¬ент-сервер. 	 
	Server 	проверка работы сервера 1С:Предприятия. Проверка компиляции модулей в режи¬ме эмуляции среды сервера 1С:Предприятия.	 
	DistributiveModules 	поставка модулей без исход¬ных текстов. В случае, если в настройках поставки конфи-гурации для некоторых моду¬лей указана поставка без ис¬ходных текстов, проверяется возможность генерации обра-зов этих модулей. 	 
	IncorrectReferences 	поиск некорректных ссылок. Поиск ссылок на удаленные объекты. Выполняется по всей конфигурации, включая права, формы, макеты, интер¬фейсы и т.д. Также осуществ¬ляется поиск логически не-правильных ссылок. 	 
	ConfigLogicallntegrity 	проверка логической целост¬ности конфигурации. Стан¬дартная проверка, обычно вы¬полняемая перед обновлением базы данных. 	 
	UnreferenceProcedures 	поиск неиспользуемых проце¬дур и функций. Поиск ло¬кальных (не экспортных) про¬цедур и функций, на которые отсутствуют ссылки. В том числе осуществляется поиск неиспользуемых обработчи¬ков событий. 	 
	HandlersExistence 	проверка существования на¬значенных обработчиков. Проверка существования об-работчиков событий интер¬фейсов, форм и элементов управления. 	 
	EmptyHandlers 	поиск пустых обработчиков. 	 
		Поиск назначенных обработ¬чиков событий, в которых не выполняется никаких дейст¬вий. Существование таких обработчиков может привести к снижению производитель¬ности системы. 
	/ReduceEventLogSize <Date>
	[-зауеАз<имя  файла>] 	сокращение журнала регист¬рации: Date — новая граница журнала регистрации в фор¬мате ГГГГ-ММ-ДД; -saveAs<MMj? файла>  -параметр для сохранения ко¬пии выгружаемых записей 
	/DumpConfigFiles <каталог вы-грузки> [-Module] [-Template] [-Help] [-AllWritable] 	осуществляет выгрузку свой¬ств объектов метаданных конфигурации 
	<каталог выгрузки> 	каталог расположения файлов свойств 
	Module 	признак необходимости вы¬грузки модулей 
	Template 	признак необходимости вы¬грузки шаблонов 
	Help 	признак необходимости вы¬грузки справочной информа¬ции 
	AllWritable 	признак выгрузки свойств только доступных для записи объектов 
	/ LoadConfigFiles <каталог вы-грузки> [-Module] [-Template] [-Help] [-AllWritable]
	<каталог выгрузки> 	осуществляет загрузку свой¬ств объектов метаданных конфигурации

	каталог расположения файлов свойств 
	Module 	признак необходимости за¬грузки модулей 
	Template 	признак необходимости за¬грузки шаблонов 	 
	Help 	признак необходимости за¬грузки справочной информа¬ции 	 
	AllWritable 	признак загрузки свойств только только доступных для записи объектов 	 
							

	Если команда пакетного режима прошла успешно, возвращает код возврата 0, в противном случае — 1 (101, если в данных имеются ошибки). После выполнения закрывает систему 1 (^Предприятие 8.0.

	Параметры командной строки пакетного режима создания фай¬лов поставки и обновления:
	/CreateDistributionFiles {-cffile<имя cf файла>] [-cfufile <имя cfu файла> [-f<имя cf файла>|-v<версия дистрибутива>]+] 	Создание файлов поставки и обновления 
	-cffile<имя cf файла> 	указание создать дистрибутив 
	-cfufile<имя cfu файла> 	указание создать обновление 
	-f<имя cf файла> 	дистрибутив, включаемый в обновление, задан именем 
	-v<версия дистрибутива> 	дистрибутив, включаемый в обновление, задан версией 
	Примечание: группа параметров -f<имя cf файла>|-у<версия дистрибутива> повторяется столько раз, сколько файлов дист¬рибутивов включается в обновление.

	Параметры командной строки режима работы с хранилищем конфигурации:
	/DepotF /DepotN /DepotP 	каталог хранилища имя пользователя хранилища
	пароль пользователя храни¬лища 
	/DepotDumpCfg<имя cf файла> [-v<номер версии хранилища>] 	сохранить конфигурацию из хранилища в файл (пакетный режим) 
	-у<номер версии храни-лища> 	v - номер версии, если номер версии не указан, или равен -1, будет сохранена последняя версия. 
	/DepotUpdateCfg [-v<номер версии хранилища>]   [-revised] 	Обновить конфигурацию хра¬нилища из файла (пакетный режим) 
	-v<номер версии храни-
	лища> 	номер версии, если номер вер¬сии не указан, или равен -1, будет сохранена последняя версия, если конфигурация подключена к хранилищу, то параметр игнорируется 
	-revised 	получать захваченные объек¬ты, если потребуется. Если конфигурация не подключена к хранилищу, то параметр игнорируется. 

	Параметры командной строки пакетного режима регистрации 1С:Предприятия 8.0 в качестве Automation сервера:
	/RegServer                                      регистрация приложения
	/UnregServer                                  удаление регистрации приложения

}//EndRegion "Запуск из командной строки"

Выгрузка конфигурации{
Конфигурация-выгрузить конфигурацию в файлы:
Формат линейный-все в одной папке. Просто будут добавлены имена к имени файла:{
	Document.ДокументДляСтатики.ObjectModule
	Document.ДокументДляСтатики
	Role.Админ.Rights
	Role.Админ
	Language.Русский
}//EndRegion "добавление к имени файла"
Формат иерархический-все будет разложено по папкам. Самый удобный вариант.
txt – для модулей и макетов текстового документа; Модули выгрузяться в текстовый файл, все остальное в основном xml.
Основным файлом в выгрузке является файл Configuration.xml, который содержит описание свойств собственно конфигурации.
Частичная загрузка может выполняться только с помощью ключа /LoadConfFromFiles пакетного запуска конфигуратора и не поддерживается в интерактивном режиме.{
Так, если необходимо загрузить справочную информацию для справочника Товары, то необходимо указать следующую команду загрузки:

1cv8 DESIGNER /IBName "IBName" /LoadConfigFromFiles D:\Source -files D:\Source\Catalogs\Товары\Ext\Help.xml
}//EndRegion "Интерактивная загрузка"


}//EndRegion "Выгрузка конфигурации"

Ширину колонок можно изменить стандартным приемом – с помощью указателя мыши при нажатой клавише Ctrl.
команды одинаковых групп из отображаемого раздела и всех его подразделов визуально размещаются в одном списке;

}//EndRegion "Remarks"

logical{
Форма создается на сервере и потом отправляется на клиент.
При изменении функциональной опции вызвать ОбновитьИнтерфейс(); или ничего не обновиться и не перерисуется.
ОткрытьФорму(){
	ОткрытьФорму(<ИмяФормы>, <Параметры>, <Владелец>, <Уникальность>, <Окно>, <НавигационнаяСсылка>, <ОписаниеОповещенияОЗакрытии>, <РежимОткрытияОкна>) 
	При открытии формы, если форма управляемая, то параметром окно можно указать владельца, обычно это ПараметрыВыполненияКоманды.Окно. Если это сделать, то можно использовать удобно навигационные ссылки-окно будет открываться в этом же документе. Иначе при нажатии на навигационную команду, откроется новое окно в новой вкладке, и при возврате во вкладку документа, у документа будет пустая форма-лишний клик для открытия формы документа.
	
	Третий параметр метода ОткрытьФорму(). Этот параметр определяет, кто будет владельцем формы выбора и кому будет приходить оповещение о сделанном выборе. В данном случае мы указали владельцем формы выбора сам элемент формы, но также мы можем указать этим параметром и саму форму. В этом случае будет необходимо реализовывать обработчик ОбработкаВыбора модуля формы и в нем решать, в какой реквизит формы помещать выбранные данные.
}

При программной модификации свойств элементов формы следует избегать неоправданной модификации свойств, для которых в синтакс-помощнике указано Изменение свойства на клиенте требует обращения к серверу. Это замедляет работу формы и требует лишних обращений к серверу.

Следует помнить, что свойства элементов формы, относящиеся к отображаемым данным (например, ПутьКДанным, ПутьКДаннымЗаголовка и т. д.), можно изменять только для новых элементов формы или после смены вида элемента формы.

При обработке завершения работы приложения (параметр ЗавершениеРаботы равен значению Истина) в обработчиках ПередЗакрытием, ПриЗакрытии, а также в обработчиках ПередЗавершениемРаботыСистемы и ПриЗавершенииРаботыСистемы запрещено использование любых серверных вызовов и открытие любых форм.
}//EndRegion "logical"

outlook word remarks{
В модулях объектов возможно объявление переменных, процедур и функций, которые будут доступны при работе с объектом извне во встроенном языке, дополняя контекст объекта. В этих модулях располагают процедуры обработки различных событий, например, ввода на основании. Также в них располагают различные процедуры, с помощью которых выполняются действия над объектом, инициированные вне данного объекта (например, выполнение печати).
Модуль объекта, это метод{//в тонком клиете управляемые формы хрен сработает. Не получить объект.
Делаем все на сервере, так как на клиенте хрен получишь. В моделе объекта в документе пишем:

&НаСервере
Процедура МетодДокументаДляСтатики() Экспорт
сообщить("Привет, работает");	
КонецПроцедуры

И в форме, в процедуре на сервере:
Объект.Ссылка.ПолучитьОбъект().МетодДокументаДляСтатики();

Если пытаться вызвать на клиенте экспортируемую функцию метода-все будет плохо. &НаСервере не может быть равен &НаКлиенте-он просто не найдет такую функцию.
}

Модуль менеджера позволяет расширить функциональность менеджеров, предоставляемых системой, за счет написания процедур и функций на встроенном языке. Фактически это позволяет описать методы для объекта конфигурации (например, справочника), которые относятся не к конкретному экземпляру объекта базы данных, а к самому объекту конфигурации. Модуль менеджера не может иметь переменных и тела модуля. 
Модуль менеджера это static.
/*Модуль менеджера
Я думаю, что в модуль менеджера нужно пихать те функции, которые в идеале хотелось бы иметь в менеджере, (они относяться к справочнику, как объекту конфигурации, дополняют функции, которые есть у СправочникМенеджер по умолчанию)-например:
СправочникМенеджер.<Имя справочника>
Стандарт:	НайтиПоКоду(<Код>, <ПоискПоПолномуКоду>, <Родитель>, <Владелец>) 
Стандарт:	ПолучитьМакет(<Макет>) 
Стандарт: ПустаяСсылка() 
дополнить бы:	ПолучитьСписокДебиторов() и реализовать её, как:	Дебиторы = Справочники.Контрагент.ПолучитьСписокДебиторов();
*/

Существует возможность программного управления списком избранного. Для этого используется объект ИзбранноеРаботыПользователя. Данный объект можно получить из хранилища системных настроек. В список избранного нельзя добавить ссылку на стандартную функцию (вызываемую с помощью команды Главное меню – Все функции – Стандартные).

При программном изменении истории работы пользователя через свойство глобального контекста ИсторияРаботыПользователя.

Открыть форму полнотекстового поиска можно с помощью команды панели инструментов или сочетания клавиш Ctrl+Shift+F.

Система «1С:Предприятие» предоставляет возможность одновременного отображения на экране нескольких форм: Специальная кнопка в области системных команд. || Контекстное меню заголовка формы. Возможности управления отображением форм аналогичны кнопке области системных команд. ||Контекстное меню элемента в панели открытых Для управления отображением форм предоставляется больше возможностей, чем предыдущие два способа.
Ключевое отличие заключается в наличии команд Показать вместе с текущим …, которые отображаются в том случае, если контекстное меню открывается у элемента, соответствующего неактивной форме  (команды Показать вместе с другим…) (команды Показать вместе с текущим…).
Для того, чтобы закрепить какую-либо форму, необходимо выбрать команду Закрепить … (любым удобным способом). При закреплении формы, она занимает 40% рабочей области (значение по умолчанию) основного окна приложения. 

Модулем управляемого приложения называется модуль, который автоматически выполняется в момент загрузки конфигурации в режиме управляемого приложения. Модуль управляемого приложения предназначен для отработки действий, связанных с сеансом работы конечного пользователя (прежде всего обработки начала и окончания сеанса работы). Модуль управляемого приложения недоступен для процедур, работающих на сервере. В нем рекомендуется реализовывать только обработчики соответствующих событий. Следует помнить, что необработанное исключение в каком-либо обработчике события модуля управляемого приложения (ПередНачаломРаботыСистемы(), ПриНачалеРаботыСистемы(), ПередЗавершениемРаботыСистемы(), ПриЗавершенииРаботыСистемы()) приведет к аварийному завершению работы всей системы.

Модуль внешнего соединения расположен, как и модуль приложения, в корневом разделе конфигурации. В нем располагаются процедуры-обработчики событий, которые инициализируются при старте и окончании работы системы в режиме внешнего соединения (СОМ-соединения). Модуль присутствует только в сессии внешнего соединения. В данном режиме характерно полное отсутствие пользовательского интерфейса.

Модулем сеанса называется модуль, который автоматически выполняется при старте системы «1С:Предприятие» в момент загрузки конфигурации. Модуль сеанса предназначен для инициализации параметров сеанса и отработки действий, связанных с сеансом работы. Этот общий модуль всегда исполняется в привилегированном режиме сервера «1С:Предприятия». Установка параметров сеанса выполняется в обработчике события УстановкаПараметровСеанса. Модуль сеанса может содержать только определения процедур и функций, может использовать процедуры из общих модулей конфигурации и не содержит экспортируемых процедур и функций.

Общие модули располагаются в отдельной ветке дерева метаданных. Основным назначением общих модулей является содержание общих алгоритмов конфигурации, доступных из разных модулей. В общих модулях отсутствует раздел определения переменных и раздел основной программы, то есть они содержат только раздел процедур и функций

В контексте модуля прикладного объекта имеется доступ к реквизитам и табличным частям объекта, а также его методам и событиям.
Каждый прикладной объект имеет менеджер, предназначенный для управления этим объектом как объектом конфигурации. С помощью менеджера можно создавать объекты, работать с формами и макетами. Модуль менеджера позволяет расширить функциональность менеджеров за счет введения процедур и функций на встроенном языке. Фактически это позволяет описать методы для объекта конфигурации (например, справочника), которые относятся не к конкретному экземпляру объекта базы данных, а к самому объекту конфигурации. В модуле менеджера справочника Контрагенты: Дебиторы = Справочники.Контрагенты.ПолучитьСписокДебиторов();

Модуль команды предназначен для того, чтобы описать в нем на встроенном языке те действия, которые должна выполнить система при вызове команды. Модуль команды может содержать только описание процедур и функций. Модуль команды не может иметь переменных и тела модуля. Обработчик ОбработкаКоманды() обязательно должен предваряться инструкцией препроцессора &НаКлиенте, т. к. именно там начинается исполнение команды.


Структуру программного модуля можно подразделить на следующие разделы:
	● раздел определения переменных,
	● раздел процедур и функций,
	● раздел основной программы.
В конкретном программном модуле любой из разделов может отсутствовать.
Раздел определения переменных размещается от начала текста модуля до первого оператора Процедура, или оператора Функция, или любого исполняемого оператора. В этом разделе могут находиться только операторы объявления переменных Перем.
Раздел процедур и функций размещается от первого оператора Процедура или оператора Функция до любого исполняемого оператора вне тела описания процедур или функций
Раздел основной программы размещается от первого исполняемого оператора вне тела последней процедуры или функции до конца модуля. В этом разделе могут находиться только исполняемые операторы. Раздел основной программы исполняется в момент инициализации модуля. 

В общем случае формат оператора языка следующий:
~метка:Оператор[(параметры)] [ДобКлючевоеСлово];
Любой исполняемый оператор может иметь метку, используемую в качестве точки перехода в операторе Перейти. (~метка:А=В;)

Регистр букв (строчные или заглавные) при написании имен переменных, свойств, методов, процедур, функций, а также функций встроенного языка не имеет значения.

Строка (String). Значения данного типа содержат строку произвольной длины в формате Unicode. Строка закодирована в формате UTF-16.
Единственный способ создать для процедуры локальную переменную с именем, совпадающим с именем переменной, определенной как глобальная, – это объявить ее явно при помощи оператора Перем.
Ключевые слова Функция, КонецФункции являются не операторами, а операторными скобками, поэтому не должны заканчиваться точкой с запятой (это может приводить к ошибкам выполнения модуля).
Программная настройка панелей{
Настройку отображения и местоположения различных панелей в основном окне приложения можно выполнить также из встроенного языка. Для выполнения настройки следует воспользоваться методами ПолучитьСостав() и УстановитьСостав() объекта НастройкиИнтерфейсаКлиентскогоПриложения. Таким образом, имеется возможность получить текущие настройки интерфейса клиентского приложение, модифицировать их нужным образом и установить обратно.

Настройки клиентского приложения хранятся в стандартном хранилище системных настроек. Ключ настроек – Общее/НастройкиИнтерфейсаКлиентскогоПриложения. Чтобы изменить настройки необходимо в начале прочитать их из хранилища:
Настройки = ХранилищеСистемныхНастроек.Загрузить("Общее/НастройкиИнтерфейсаКлиентскогоПриложения");
Затем настройки можно модифицировать и поместить обратно в хранилище:
ХранилищеСистемныхНастроек.Сохранить("Общее/НастройкиИнтерфейсаКлиентскогоПриложения", "", Настройки);
После сохранения нового варианта настроек, необходимо выполнить перестроение интерфейса клиентского приложения с помощью вызова метода ОбновитьИнтерфейс().
пример- при каждом начале работы устанавливать вариант интерфейса клиентского приложения, из одной панели (панели инструментов), вдоль левого границы.{
Процедура МинимальныйИнтерфейс() Экспорт
    Настройки = Новый НастройкиИнтерфейсаКлиентскогоПриложения;
    НастройкиСостава = Новый НастройкиСоставаИнтерфейсаКлиентскогоПриложения;
    НастройкиСостава.Лево.Добавить(Новый ЭлементНастройкиСоставаИнтерфейсаКлиентскогоПриложения("ПанельИнструментов"));
    Настройки.УстановитьСостав(НастройкиСостава);
    ХранилищеСистемныхНастроек.Сохранить("Общее/НастройкиИнтерфейсаКлиентскогоПриложения", "", Настройки);
КонецПроцедуры

В модуле управляемого приложения необходимо разместить обработчик события ПриНачалеРаботыСистемы:

Процедура ПриНачалеРаботыСистемы()
    РаботаСИнтерфейсом.МинимальныйИнтерфейс();
    ОбновитьИнтерфейс();
КонецПроцедуры

В результате, вне зависимости от того, какие настройки осуществил пользователь в предыдущем сеансе работы, каждый новый сеанс будет начинаться с минимального интерфейса.
}//EndRegion "Пример"
}//EndRegion "Программная настройка панелей"

 Общий модуль может содержать только определения процедур и функций.{
Процедуры и функции общего модуля, для которых в заголовках указано ключевое слово Экспорт, являются одними из составных частей глобального контекста.Свойство Глобальный определяет, являются ли экспортируемые методы общего модуля частью глобального контекста.
Если свойство Глобальный установлено в значение Истина, то экспортируемые методы общего модуля доступны как методы глобального контекста.
Если свойство Глобальный установлено в значение Ложь, то в глобальном контексте создается свойство с именем, соответствующим имени общего модуля в метаданных. Данное свойство доступно только для чтения. Значением данного свойства является объект ОбщийМодуль. Через данный объект доступны экспортируемые методы данного общего модуля. Таким образом, обращение к методам неглобальных общих модулей выглядит как XXXXX.YYYYY, где XXXXX – это имя свойства, соответствующее контексту общего модуля, а YYYYY – имя экспортируемого метода общего модуля.
Если у общего модуля установлено свойство Сервер и еще какое-либо свойство, то это означает, что общий модуль будет доступен одновременно на сервере и в выбранном клиенте. При этом необходимо понимать, что фактически это будет несколько вариантов скомпилированного кода (по числу выбранных клиентов и собственно для сервера).
Свойство Вызов сервера предназначено для управления возможностью вызова экспортируемых методов серверного общего модуля из клиентского кода. Если свойство установлено, то экспортируемые методы серверного общего модуля доступны для вызова со стороны клиента. Если свойство не установлено, то такие экспортируемые методы можно вызывать только из серверных методов (как методов серверных общих модулей, так и серверных методов модуля формы и модулей команд).
 }//EndRegion "CommonModule"
 
Общий Модуль{
Свойство «вызов сервера» имеет смысл при наличии только одного свойства общего модуля «компиляции на Сервере».
Если серверный модуль имеет свойство глобальный-вызвать у меня не получилось.
В одном общем модуле, имеющем несколько мест компиляции («Сервер, клиент») нельзя вызывать из клиентской процедуры серверную того же модуля, даже если поставить галку «вызов сервера».


Есть общий модуль под названием "ОбщийМодуль2" в нем процедура на сервере, которую хочу вызвать с клиента:
	&НаСервере
	Процедура ПриветССервера() Экспорт
На форме происходит нажатие команды:
	Если у модуля галочки:
		1-сервер
		2-вызов сервера
	то процедура выполняется:
		ОбщийМодуль2.ПриветССервера();
	
	Если у модуля галочки:
		1-клиент
		2-сервер
		3-вызов сервера
	то получаем ошибку:ОбщийМодуль2.ПриветССервера(); "Метод объекта не обнаружен (ПриветССервера)"
	
	Если у модуля галочки:
		1-глобальный
		2-сервер
		3-вызов сервера
	то ОбщийМодуль2.ПриветССервера(); приводит к ошибке: " Переменная не определена (ОбщийМодуль2)"
	то ПриветССервера(); приводит к ошибке "Процедура или функция с указанным именем не определена (ПриветССервера)"
}

Если общий модуль не является глобальным, то становится доступно свойство Повторное использование возвращаемых значений.{
Это свойство может принимать следующие значения:● На время вызова и На время сеанса – для общего модуля используется метод определения повторного использования данных. Суть этого метода заключается в том, что в ходе выполнения кода система запоминает параметры и результат работы функций после первого вызова функции. При повторном вызове функции с такими же параметрами, происходит возврат запомненного значения (из первого вызова) без выполнения самой функции. Если функция во время своего выполнения меняет значения параметров, то повторный вызов функции не будет это делать.
Суть вот в чем-функция запоминает аргумент и возвращаемое значение. При вызове функции, если аргумент уже был использован-если она его помнит, то она не будет ничего выполнять и просто вернет значение. А если аргумент другой-то функция выполниться и заполнит и его. Теперь она уже помнит два аргумента, и два их результата...Так как функция не будет выполняться, то возможен непредвиденный косяк- функция принимает аргумент и возвращает текущую дату. При аргументе 1 она вернет время 13-23-44, при аргументе 2 она вернет время 14-25-03, и если через четыре минуты вызвать функцию с аргументом 1, то дата все равно будет 13-23-44. Нужно аккуратно быть с этим.
Где-то через 6-20 мин они удаляться автоматически. Ну или если что-то координальное произойдет-у сервера закончиться оперативка, программа завершиться...
Если функция общего модуля, с установленным повторным использованием, вызываются из этого же самого общего модуля (например, с именем ОбщийМодуль), то следует помнить о следующей особенности: если функция вызывается по имени МояФункция(), то исполнение функции будет происходить при каждом вызове функции. Для того чтобы использовались сохраненные значения, функция следует вызывать по полному имени: ОбщийМодуль.МояФункция().
Метод глобального контекста ОбновитьПовторноИспользуемыеЗначения() удаляет все повторно используемые значения, как на стороне сервера, так и на стороне клиента, независимо от места вызова метода. После выполнения метода ОбновитьПовторноИспользуемыеЗначения() первый вызов функции будет выполнен полностью.
На выполнение процедур данное свойство общих модулей не влияет – процедуры выполняются всегда.
}//EndRegion "Повторное использование возвращаемых значений"


Параметры сеанса предназначены в основном для использования значений параметров в запросах и условиях ограничения доступа к данным для текущего сеанса.{
Использование параметров сеанса снижает время доступа к данным за счет исключения связанных таблиц. Настройка параметров сеанса производится в палитре свойств. Инициализация параметров сеанса может выполняться в модуле сеанса, в обработчике события УстановкаПараметровСеанса(). До инициализации значение параметр сеанса неопределено. При попытке чтения такого параметра сначала вызывается обработчик события УстановкаПараметровСеанса(). Если после вызова состояние параметра остается неопределенным, то вызывается исключение.
Для каждого параметра сеанса определены два права доступа – Получение и Установка (подробнее о правах см. раздел ниже). Если право Установка снято, то инициализация данного параметра сеанса возможна только в общем модуле с установленным свойством Привилегированный или в модуле сеанса.
 Параметры сеанса доступны как из встроенного языка «1С:Предприятия», например:
ПараметрыСеанса.ТекущийПользователь = ИмяПользователя();
Объем данных, перемещаемых между клиентом и сервером, для установки одного параметра сеанса, не должен превышать 4 Gb (в сериализованном виде).
}//EndRegion "Параметры сеанса"
Подводные камни параметров сеанса{
1:
	Сначало ты должен в конфигурация->параметрыСеанса создать его. Или ты ручками создаешь его или получаешь Error при попытке записать в несуществующий:
		ПараметрыСеанса.вася = "Вася"; //такого нет, и будет ошибка с падением программы
		ПараметрыСеанса.ПараметрСеанса1="Он Создан";
2:
	Для каждого параметра сеанса определены два права доступа – Получение и Установка (подробнее о правах см. раздел ниже). Если право Установка снято, то инициализация данного параметра сеанса возможна только в общем модуле с установленным свойством Привилегированный или в модуле сеанса:
		Если ты создал параметр сеанса и написал:
			&НаКлиенте
			Процедура ОбработкаКоманды(ПараметрКоманды, ПараметрыВыполненияКоманды)
				сообщить(ПолучитьССервераПараметрСеанса());	
			КонецПроцедуры

			&НаСервере
			Функция ПолучитьССервераПараметрСеанса()
				возврат ПараметрыСеанса.ПараметрСеанса1;
			КонецФункции
		то получишь ошибку, потому что у тебя нет прав: "Нарушение прав доступа".
Если поставил у роли: получение, то спокойно функция получается-ты в модуле сеанса установил значение и теперь можешь где угодно получить параметр сеанса. Но если попробуешь на сервере (в тонком клиенте их не получить) написать:
	ПараметрыСеанса.ПараметрСеанса1="Измена";
то все равно будет ошибка "Нарушение прав доступа", для этого кроме получения надо установить и установка.
Ставим получение и установка и можем в любом месте программы менять и получать параметр сеанса.

}//EndRegion "underwater stone"

Нужно отличать параметры сеанса от глобальной переменной:
	Пишем в модуле упрвляемого приложения:
	Перем НазваниеПеременной1 Экспорт;  //теперь это глобальная переменная.
	И из любого места можем обратиться к этой переменной-она глобальная и сохраняет значение-и из экспортной процедуры общего модуля и из формы и из команд....
	
Роли и права{
В системе «1С:Предприятие» различают два типа прав – основные и интерактивные. Основные проверяются всегда, независимо от способа обращения к объектам информационной базы. Интерактивные проверяются при выполнении интерактивных операций (просмотр и редактирование в форме и т. д.).
	
}//EndRegion "Роли и права"

Привилегированный режим работы{
На сервере «1С:Предприятия» фрагменты кода могут исполняться как в обычном, так и в привилегированном режиме. В привилегированном режиме не выполняется проверка доступа на уровне записей, не производится контроль прав и разрешены любые операции, что ускоряет выполнение модулей.
Для управления привилегированным режимом предназначен метод глобального контекста УстановитьПривилегированныйРежим()
По умолчанию привилегированный режим выключен. Количество включений привилегированного режима должно совпадать с количеством выключений. Однако если внутри процедуры или функции происходило включение привилегированного режима (один раз или более), но не происходило его выключение, то система автоматически выполнит выключение столько раз, сколько незавершенных включений было в покидаемой процедуре или функции. Если в процедуре или функции вызовов метода УстановитьПривилегированныйРежим(Ложь) сделано больше, чем вызовов метода УстановитьПривилегированныйРежим(Истина), то будет вызвано исключение.
Функция ПривилегированныйРежим() возвращает Истина, если привилегированный режим еще включен, и Ложь, если он полностью выключен. При этом не анализируется количество установок привилегированного режима в конкретной функции.
Программная установка привилегированного режима может потребоваться в случае массированных операций с данными информационной базы, и при этом нет смысла проверять права доступа к данным. Например, существует пользователь, которому доверили выполнять пересчет цен товаров. Тогда в обработке, например, которая это выполняет, можно проверить право текущего пользователя выполнять данную обработку, а затем включить привилегированный режим и выполнить все необходимые операции с базой данных. При этом у пользователя может не быть прав на чтение цен. Но так как данная обработка не выдает пользователю самих цен, а только их пересчитывает, то поставленные задачи ограничения доступа будут также решены.
Также существует возможность стартовать привилегированный сеанс. Это сеанс, в котором привилегированный режим установлен с самого начала работы системы. При этом во время работы метод ПривилегированныйРежим() будет всегда возвращать Истина, а возможность отключить привилегированный режим не поддерживается. Стартовать привилегированный сеанс может только пользователь, которому доступны административные права (право Администрирование). Запуск сеанса можно выполнить с помощью ключа командной строки запуска клиентского приложения UsePrivilegedMode или параметра строки соединения с информационной базой prmod.
}//EndRegion "Привилегированный режим работы"

Безопасный режим работы{
В случае необходимости использования на сервере «ненадежного» программного кода: внешние обработки или программный код, вводимый пользователем для использования в методах Выполнить() и Вычислить(), можно воспользоваться безопасным режимом работы.
рограммная установка безопасного режима может потребоваться в том случае, когда разработчик конфигурации предполагает использование стороннего (по отношению к конфигурации) программного кода, надежность которого разработчик гарантировать не может. Примером такого кода является выполнение методов Выполнить() и Вычислить() в тех случаях, когда исполняемый код получается из внешнего мира. В этом случае хорошей практикой будет установка безопасного режима до выполнения этих методов:

// Формируется программный код, который следует исполнить
// Возможно, что код загружается из внешних источников
// или введен вручную
ИсполняемыйКод = ПолучитьВыполняемыйКодИзВнешнегоМира();
// Включим безопасный режим
УстановитьБезопасныйРежим(Истина);
// Выполним потенциально опасный код
Выполнить(ИсполняемыйКод);
// Выключим безопасный режим
УстановитьБезопасныйРежим(Ложь);
В безопасном режиме:
● Привилегированный режим отменяется.
● Переход в привилегированный режим игнорируется.
● Запрещены операции, приводящие к использованию внешних средств по отношению к платформе «1С:Предприятие»:
● Механизмы COM:
	● COMОбъект(),
	● ПолучитьCOMОбъект(),
	● ОболочкаHTMLДокумента.ПолучитьCOMОбъект().
	● Загрузка внешних компонентов:
	● ЗагрузитьВнешнююКомпоненту(),
	● ПодключитьВнешнююКомпоненту().
● Доступ к файловой системе:
	● ЗначениеВФайл(),
	● КопироватьФайл(),
	● ОбъединитьФайлы(),
	● ПереместитьФайл(),
	● РазделитьФайл(),
	● СоздатьКаталог(),
	● УдалитьФайлы(),
	● Новый Файл,
	● Новый xBase,
	● ЗаписьHTML.ОткрытьФайл(),
	● ЧтениеHTML.ОткрытьФайл(),
	● ЧтениеXML.ОткрытьФайл(),
	● ЗаписьXML.ОткрытьФайл(),
	● ЧтениеFastInfoset.ОткрытьФайл(),
	● ЗаписьFastInfoset.ОткрытьФайл(),
	● КаноническаяЗаписьXML.ОткрытьФайл(),
	● ПреобразованиеXSL.ЗагрузитьИзФайла(),
	● ЗаписьZipФайла.Открыть(),
	● ЧтениеZipФайла.Открыть(),
	● Новый ЧтениеТекста(),
	● Новый ЗаписьТекста(),
	● Новый ИзвлечениеТекста(),
	● изменение свойства ИзвлечениеТекста.ИмяФайла,
	● ИзвлечениеТекста.Записать(),
	● Новый Картинка(), если первый параметр – строка;
	● Картинка.Записать();
	● Новый ДвоичныеДанные();
	● ДвоичныеДанные.Записать();
	● ФорматированныйДокумент.Записать();
	● ГеографическаяСхема.Прочитать();
	● ГеографическаяСхема.Записать();
	● ГеографическаяСхема.Напечатать();
	● ТабличныйДокумент.Прочитать();
	● ТабличныйДокумент.Записать();
	● ТабличныйДокумент.Напечатать();
	● ГрафическаяСхема.Прочитать();
	● ГрафическаяСхема.Записать();
	● ГрафическаяСхема.Напечатать();
	● ТекстовыйДокумент.Прочитать();
	● ТекстовыйДокумент.Записать().
● Доступ к Интернету:
	● Новый ИнтернетСоединение,
	● Новый ИнтернетПочта,
	● Новый ИнтернетПрокси,
	● Новый HTTPСоединение,
	● Новый FTPСоединение.
}//EndRegion "Безопасный режим работы"

Cуществует возможность непосредственного удаления объектов средствами встроенного языка. Поэтому элементы конкретной конфигурации могут выполнять непосредственное удаление в обход механизма контроля ссылочной целостности

Ограничения доступа проверяются при любом выполнении соответствующих операций над объектами базы данных (из диалогов, из встроенного языка, посредством запросов) и могут действовать одним из двух способов:
	 ● Все. Способ «все» подразумевает, что некоторая операция над данными (из диалогов, из встроенного языка или посредством запросов) должна быть выполнена над всеми подразумеваемыми данной операцией объектами базы данных. Если при выполнении такой операции должны быть прочитаны или изменены объекты базы данных, для которых не выполняются соответствующие ограничения доступа, то операция завершается аварийно из-за нарушения прав доступа.
	● Разрешенные. Способ «разрешенные» подразумевает, что при выполнении операции над данными должны быть прочитаны только те объекты базы данных, которые удовлетворяют соответствующим ограничениям доступа. Объекты базы данных, не удовлетворяющие ограничениям доступа, при выполнении такой операции считаются отсутствующими и на результат операции не влияют.
Ограничения доступа к данным накладываются на объекты базы данных в момент обращения «1С:Предприятия» к базе данных. В клиент-серверном варианте «1С:Предприятия» наложение ограничений выполняется на сервере «1С:Предприятия».

Общий реквизит:
	1-Как общий реквизит, т. е. для упрощения указания реквизита, который присутствует во всех или многих объектах конфигурации, в которых этот реквизит сохраняет свой смысл и тип. В качестве примера такого использования общего реквизита можно привести поле произвольного комментария в документах прикладного решения. Если во всех документах требуется иметь реквизиты Автор и Редактор, нет необходимости создавать такие реквизиты в каждом документе. Достаточно создать два общих реквизита (Автор, Редактор) и указать, в каких документах они будут использоваться.
	2-Как составная часть разделения данных – специального механизма, позволяющего разделить все хранимые данные, а также работу прикладного решения на отдельные части. При этом у общего реквизита включается разделение данных. В качестве примера такого использования можно привести понятие абонента, когда в одной физической информационной базе могут независимо работать различные «владельцы» данных, при этом пользователи такого прикладного решения будут считать, что в информационной базе кроме «их» данных нет больше ничего.
	
Подписки на события позволяют назначать обработчики событий для одного объекта или группы объектов встроенного языка. События не на форму, к форме и нажатию там клавишь не придерешься, события идут на объект конфигурации, как на объект базы данных-при проведении, при заполнении, при установке нового номера. Оно выполняется на сервере.

Основными возможностями механизма заданий являются:
	● определение регламентных процедур на этапе программирования системы;
	● выполнение заданных действий по расписанию;
	● выполнение вызова заданной процедуры или функции асинхронно, т. е. без ожидания ее завершения;
	● мониторинг хода выполнения заданий;
	● управление заданиями (отмена, блокировка выполнения и др.);
	● возможность ожидания завершения одного или нескольких заданий.
Механизм фоновых заданий реализуется средствами встроенного языка. Фоновые задания предназначены для выполнения прикладных задач асинхронно. Они могут порождать дочерние фоновые задания, например, для распараллеливания сложных вычислений по различным рабочим серверам кластера в клиент-серверном варианте работы.
В процессе запуска регламентное задание порождает фоновое задание, которое и выполняет реальную обработку. Регламентное задание может выполняться от имени заданного пользователя и имеет возможность перезапуска (например, в случае непредвиденного завершения работы).
Функциональные опции позволяют разработчику описать возможности прикладного решения, которые можно оперативно включать или выключать на этапе внедрения и/или в процессе работы системы. Например, возможность работы с дополнительными свойствами товаров можно выделить в отдельную функциональную опцию. Тогда если отключить эту возможность, в интерфейсе прикладного решения «пропадут» все связанные (с дополнительными свойствами товаров) возможности.{
Можно создать функциональную опцию склад-тогда во всех документах будет склад виден. Нажмешь на галочку-отменишь функциональную опцию и изо всех документов пропадет склад.
На алгоритмы, написанные на встроенном языке – имеется возможность получать значения функциональных опций из встроенного языка и использовать их в различных условиях, например, для уменьшения объема вычислений.
Влияние функциональных опций на глобальный командный интерфейс заключается в том, что система скрывает команды всех объектов, относящихся к выключенным опциям. Например, если значение функциональной опции Закупки равно значению Ложь, то будут скрыты команды открытия раздела Закупки, создания документа ПриходТовара, открытия списка ПриходТовара и т. д.
}
Система способна автоматически учитывать состояние сделанных настроек – скрывать выключенные возможности, делая интерфейс приложения более ясным и понятным для пользователя.
При разработке возникают ситуации, когда значение функциональной опции должно зависеть от неких параметров, например, валютный учет ведется не у всех организаций. Для реализации такой зависимости служат Параметры функциональных опций – объекты, параметризующие функциональные опции.
Как работает функциональная опция{
	опцию для нормального использования по умолчанию надо хранить в булевом реквизите справочника, регистра или константы. допустим в справочнике создаем реквизит булево и храним в нем опцию. К опции привязываем документ и если значение реквизита справочника истина-документ виден. Убираем галку с этого реквизита и все-при следующей перезагрузке документ не будет виден.
	Или вместо документа можно выбрать реквизит-опция true -реквизит виден. Убираем галочку-реквизит не виден. Можно и команды формы запихнуть в фунциональные опции...
	ОбновитьИнтерфейс(); пихать после изменений опции или придется заново все перезапускать.
	Информация о типах, отключенных функциональными опциями, кешируется на стороне клиента и очищается через 20 минут или во время вызова метода ОбновитьИнтерфейс().
}

Определяемый тип{
	– это специальный объект конфигурации, который предназначен для упрощения и повышения удобства внедрения подсистем при разработке прикладного решения. В качестве примера можно рассмотреть универсальную подсистему, предназначенную для хранения контактной информации. В состав этой подсистемы входит регистр сведений, который хранит эту информацию. В этом регистре есть измерение, которое указывает, для какого объекта хранится контактная информация. В качестве значения измерения может выступать контрагент, собственная организация, физическое лицо и т. д. Причем тип (с именем СправочникиОрганизацийИФизическихЛиц), описывающий этот объект хранения, может встречаться не только в качестве типа измерения регистра. В процессе внедрения прикладного решения состав такого типа может изменяться – в него могут добавляться новые справочники или из его состава могут исключаться «лишние» типы. Если вместо типа СправочникиОрганизацийИФизическихЛиц использовать составной тип в каждом месте, где используется такая сущность, то придется везде изменять состав типов. Это сложно и существует возможность забыть о каком-либо реквизите с нужным составным типом. Если использовать определяемый тип, то в процессе доработки прикладного решения будет необходимо изменить только состав определяемого типа (и, естественно, все фрагменты прикладного кода, где этот тип используется). Все реквизиты, для которых в качестве типа указан тип СправочникиОрганизацийИФизическихЛиц, будут изменены автоматически.
Определяемый тип обладает следующими особенностями:
	● Может быть составным;
	● Не может входить в состав типа значения плана видов характеристик;
	● Не может входить в состав составного типа данных другого реквизита;
	● Определяемый тип не может входить в состав другого определяемого типа;
	● Определяемый тип не может входить в состав типа следующих объектов:
		● Признак учета плана счетов;
		● Признак учета субконто плана счетов;
		● Тип номера нумератора.
Для описания типа на встроенном языке следует использовать конструкцию вида ОпределяемыйТип.<ИмяОпределяемогоТипа>.
}//EndRegion "Определяемый тип"

Для сохранения информации о настройках пользователя, которые должны сохраняться между сеансами работы, в платформе реализованы хранилища настроек:{
	● Стандартное хранилище – хранилище, используемое системой по умолчанию и хранящее данные в системных таблицах информационной базы.
	● Хранилища настроек – специальные объекты метаданных, которые описывают хранение данных в некотором объекте информационной базы. Например, в этом объекте может быть описана работа с настройками, которые хранятся в справочнике.
Создавать собственное хранилище имеет смысл в тех случаях, когда необходима особая структура хранения настроек, необходимы специальные механизмы управления настройками, требуется обмен настройками в рамках распределенной базы данных (см. здесь) и других аналогичных случаях.
Хранилище настроек может использоваться как только для программной работы, так и для программной и интерактивной работы. В первом случае для обеспечения необходимой функциональности требуется обязательная реализация обработчиком модуля объекта ХранилищеНастроек:
	● ОбработкаСохранения – содержит реализацию метода Сохранить(). В данном обработчике необходимо выполнить сохранение настройки в некоторый объект. Например, в элемент справочника.
	● ОбработкаЗагрузки – содержит реализацию метода Загрузить(). В данном обработчике необходимо получить настройки из некоторого объекта. Например, из элемента справочника.
Если не реализовать тот или иной обработчик, то будет недоступно выполнение действия, которое обработчик реализует. Например, если не реализовать обработчик ОбработкаСохранения, будет недоступно сохранение настроек.
В процессе разработки хранилища разработчик самостоятельно определяет, каким образом будет идентифицироваться объект хранилища, тем самым определяя тип параметра. Например, если настройки сохраняются в справочнике, то в качестве ключа настройки можно использовать поле Код или значение Ссылка (элемента справочника).
Если для работы с настройками требуется интерактивность (формы сохранения и восстановления настроек), то необходимо реализовать формы сохранения и восстановления настроек и заполнить соответствующие свойства объекта ХранилищеНастроек (Основная форма сохранения и Основная форма загрузки). Реализация форм сохранения и восстановления настроек является обязательной для выполнения интерактивных операций. Программное сохранение и восстановление настроек возможно и без реализации этих форм.
Когда пользователь применяет команды сохранения или загрузки настроек, система получает соответствующую форму объекта хранилища настроек и отображает ее на экране. Например, при сохранении настроек отчета система будет использовать форму сохранения того объекта метаданных, который указан в качестве хранилища настроек отчетов (непосредственно у самого отчета или у всей конфигурации). При этом форме будут переданы параметры, более подробную информацию о которых можно получить в описании объекта ОписаниеНастроек в синтакс-помощнике.
При создании формы с помощью конструктора необходимые параметры будут автоматически добавлены в список параметров формы.
В формах следует использовать переданные параметры и соответствующим образом фильтровать список настроек. Так, следует отображать только настройки для указанного в параметре КлючОбъекта объекта настройки (например, отчета)
}
Тема о хранилище настроек своими словами{
	При создании формы, можем сделать реквизит формы, и тогда появиться колонка сохранение, а у самого ревизита есть свойство "сохраняемые данные" в обоих этих чекбоксах можно проставить галки, и не факт, что галки буду совпадать.
	У формы в свойстве "СохранениеДанныхВНастройках" можем поставить сохранять. и тогда появиться поле выбора хранилища настроек. Выбираем ранее созданное. 
	При открытии формы в списке команд "еще" появиться команды "сохранить параметры" и "восстановить параметры", при нажатии на сохранитьПараметры открывается форма сохранения того хранилища настроек, которое выбрали у формы. Так по идее можно куда-то запихнуть реквизиты при закрытии формы.
}//EndRegion "хранилище настроек"

Механизм общих форм позволяет использовать формы, доступные из любого модуля текущей конфигурации.
У общей формы при создании есть свойство "использовать стандартные команды", если установить true, то в "Сервис" появиться команды открытия это формы, и из формы документа, через глобальные команды можно перетащить команду открытия этой общей формы.
Если создается общая форма, которая будет использоваться в качестве формы отчета, настроек отчета или варианта, то не рекомендуется для такой формы устанавливать свойство Использовать стандартные команды.

Чтобы картинка при вставке хорошо вписывалась в элемент управления или форму, желательно установить ей прозрачный фон. Для установки прозрачного фона нужно нажать кнопку Установить прозрачный фон. Указатель мыши изменит вид. Подвести курсор к той части картинки, цвет которой нужно сделать прозрачным, и щелкнуть левой кнопкой мыши. Выбранный цвет становится прозрачным. Кнопки Установить прозрачный фон и Убрать прозрачность доступны только для картинок форматов bmp, jpg и tiff.

Механизм XDTO является универсальным способом представления данных для взаимодействия с различными внешними источниками данных и программными системами. 

Web-сервис{
Для получения доступа к Web-сервису необходимо использовать адрес, который формируется следующим образом: <Имя хоста веб-сервера>/<Имя виртуального каталога>/ws/<Имя Web-сервиса> или <Имя хоста веб-сервера>/<Имя виртуального каталога>/ws/<Адрес Web-сервиса>.

Так, если виртуальный каталог имеет имя DemoWS, имя Web-сервиса в конфигураторе указано как ДемонстрацияРаботыWS, а в качестве адреса указано DemoWorkWS, то обращение к Web-сервису можно выполнять одновременно по двум адресам (для получения доступа с локальной машины): http://localhost/DemoWS/ws/ДемонстрацияРаботыWS или http://localhost/DemoWS/ws/DemoWorkWS.	
}//EndRegion "Web-сервис

Элементы стиля {предназначены для единообразного оформления различных элементов формы в тех случаях, когда недостаточно того оформления, которое автоматически предлагает «1С:Предприятие». 
Например, требуется цвет каких-либо надписей в формах конфигурации сделать одинаковым. В этом случае логично создать элемент стиля, задать ему цвет и использовать созданный элемент для установки цвета текста элемента формы.
Элементы стиля могут быть трех разных видов:
	● Цвет,
	● Шрифт,
	● Рамка.
Имеется возможность программного доступа к значению элемента стиля с помощью свойства Значение.
Пример:
	Метаданные.ЭлементыСтиля.ЦветОтрицательного.Значение
}//EndRegion "Элементы стиля"
	
Языки{
внизу у формы есть группа языки, там можно менять язык: с помощью кнопки выбора языка, расположенной в панели состояния справа от кнопок CAP и NUM (правый нижний угол основного окна конфигуратора).
После этого текст надписей замениться на аналогичные, ранее установленные.
текст надписей должен быть заранее введен для каждого элемента управления. Для ввода текста в палитре свойств элемента управления Надпись в свойстве Заголовок (Текст или Синоним, в зависимости от типа элемента управления) нужно нажать кнопку «лупа». На экран выводится окно Строки на разных языках.
Если в конфигурации определено два и более объекта типа Языки, то для свойства Синоним и Заголовок элемента управления появляется кнопка редактирования текста на разных языках (в виде лупы).
}//EndRegion "Языки"

Комментарий – произвольная строка символов. Как правило, расшифровывает и поясняет имя объекта.
Пояснение-то что вылазиет всплывающей подсказкой при наведении на этот объект. Допустим у документа что-то пишем и потом наводим на него в подсистеме, вылезет эта надпись.	- используется для формирования подсказки к стандартным командам 

В системе «1С:Предприятие» существуют объекты, которые необходимо нумеровать в автоматическом или ручном режиме.{
При использовании строкового кода/номера необходимо понимать, как работает нумерация. Рассмотрим пример нумерации. Тип кода справочника – Строка. Длина кода – 3 символа. Допустим, оператор ввел номер 01 и записал элемент справочника. В результате этого действия максимальное значение номера, который может быть создан системой автоматической нумерации, будет равен 99. Это произошло потому, что при ручном вводе нового номера произошло явное ограничение длины номер двумя разрядами. Система автоматической нумерации «не умеет» автоматически расширять создаваемый номер, если длина номера явно ограничена.	
	
Таким образом, для того, чтобы автоматическая нумерация строковых кодов/номеров работала хорошо, рекомендуется или не указывать номера вручную или задавать лидирующие нули так, чтобы любой код/номер всегда был максимально возможной длины (с учетом ведущих нулей).

То есть, я создаю новый документ, он по умолчанию автонумеруется. Создаю пару документов-у них номер будет 000000001 и 000000002 в следующем ставлю номер 3 и создаю еще: у них будут номера 4,5,6,7,8,9, ошибка так как номер 9 не уникально. Из-за ручного ввода одного числа 3, длина номера сбросилась с 9 по умолчанию на 1.
}//EndRegion "Нумерация"

Связь по типу – устанавливает связь с реквизитом, ограничивая тип вводимых значений для поля ввода. Настройка связи по типу имеет смысл для реквизитов с составным типом данных, логически связанных с другим реквизитом типа ПланВидовХарактеристик.Ссылка, в том числе для связи реквизита, содержащего субконто с реквизитом, который содержит значение типа Ссылка на план счетов. -можно создать два реквизита составного типа. У одного числа, строка, дата и у другого такие же типы-при смене типа у первого реквизита, другой обнуляется и принимает такой же тип-первому дату, у второго тоже появиться календарь, первому строку-и второй станет строкой...

Основное отличие табличной части от подчиненного справочника в том, что на элементы справочника можно ссылаться, а на строки табличной части – нет. При обращении к элементу справочника он весь, вместе со всеми табличными частями, считывается из базы данных в память.Поэтому табличную часть стоит использовать, если не нужно хранить ссылки на элементы и количество элементов ограничено.

ВНИМАНИЕ! Для справочника, имеющего владельца, нельзя создать предопределенные элементы. И наоборот, справочнику, имеющему предопределенные элементы, нельзя назначить владельца.

Индексирование и индексирование с доп упорядочиванием{
При описании в метаданных реквизитов различных объектов существует возможность установить свойство Индексировать. Это свойство позволяет разработчику конфигурации указать системе необходимость построения в базе данных отдельного индекса по соответствующему реквизиту.
Кроме варианта "Индексировать" в данном свойстве для большинства объектов можно установить вариант "Индексировать с доп. упорядочиванием". Данный вариант предназначен, прежде всего, для использования в динамических  списках.
В варианте "Индексировать" строится индекс непосредственно по реквизиту. Индекс также дополняется ссылкой, чтобы обеспечить определенный порядок записей в индексе при повторяющихся значениях реквизита.
В варианте "Индексировать с доп. упорядочиванием" индекс строится по реквизиту, а также по некоторому полю, которое обычно используется для упорядочивания объектов этого типа. Для справочника индекс в зависимости от основного представления дополняется кодом или наименованием. А для документа, индекс дополняется датой. Этот индекс также дополняется ссылкой.
В варианте "Индексировать" в динамическом списке может быть обеспечен эффективный просмотр больших объемов информации с упорядочиванием по данному реквизиту, так как для этого будет использоваться созданный индекс.
В варианте "Индексировать с доп. упорядочиванием" в динамическом списке может быть обеспечен эффективный просмотр больших объемов информации с отбором по значению данного реквизита и с упорядочиванием, соответствующим основному упорядочиванию для данного объекта. В этом случае наличие индекса включающего реквизит, по которому выполняется отбор, и поля основного упорядочивания позволит системе использовать индекс при просмотре списка.
Таким образом при определении варианта свойства Индексировать следует исходить из того, какие варианты выборки информации необходимо оптимизировать в первую очередь. Например, если требуется просмотр списка с отбором по реквизиту, то имеем смысл использовать вариант "Индексировать с доп. упорядочиванием". А если индекс нужен, например, только для поиска с помощью запроса объектов по данному реквизиту без упорядочивания, то лучше использовать вариант "Индексировать", чтобы создаваемые индекс требовал меньше ресурсов системы.   
}//EndRegion "Индексирование и индексирование с доп упорядочиванием"

Момент времени и оперативная отметка времени, пояса и прочее{
Для определения положения документа на оси времени используется реквизит документа Дата, который содержит время с точностью до секунды. Однако при большом объеме создаваемых документов вероятна ситуация, когда несколько документов будут иметь одинаковое значение даты (т. е. будут созданы в течение одной секунды).
Для обработки подобных ситуаций существует понятие момент времени. Момент времени представляет собой совокупность даты, времени и ссылки на объект базы данных. Он позволяет однозначно идентифицировать любой объект ссылочного типа базы данных на оси событий, но имеет смысл в основном только для документов. Кроме того, момент времени позволяет идентифицировать и необъектные данные, например, записи регистров, подчиненных регистратору.
Понятие момента времени реализовано во встроенном языке при помощи универсального объекта МоментВремени.
Для нескольких документов, имеющих одинаковую дату и время, последовательность их на оси событий определяется системой исходя из ссылок на эти документы. Она может не совпадать с последовательностью создания документов, и она недоступна для изменения пользователем, то есть нельзя каким-либо образом повлиять на последовательность документов внутри одной секунды или «вычислить», что один документ создан раньше, а другой – позже.
Оперативная отметка времени – это значение типа Дата. Оперативная отметка времени – это «основа», которая собственно и позволяет выполнять оперативное проведение документов. Оперативная отметка времени создается системой каждый раз при оперативном проведении документа. Ее значение формируется исходя из текущей даты сеанса и последней созданной оперативной отметки.
	

При работе системы в различных часовых поясах необходимо учитывать эту особенность при получении оперативной отметки времени.
Часовой пояс информационной базы определяет часовой пояс, который по умолчанию будет установлен для нового сеанса. При создании информационной базы часовой пояс информационной базы не определен. Однако может быть установлен с помощью метода глобального контекста УстановитьЧасовойПоясИнформационнойБазы(). Информация о часовом поясе информационной базы сохраняется в базе данных и не меняется при операциях загрузки/выгрузки информационной базы.
Часовой пояс сеанса описывает тот часовой пояс, в котором работает конкретный сеанс. По умолчанию часовой пояс сеанса равен часовому поясу информационной базы.
Часовой пояс сеанса может быть установлен с помощью метода глобального контекста УстановитьЧасовойПоясСеанса(). Часовой пояс сеанса сохраняется до конца сеанса. Используется для определения текущей даты сеанса и получения оперативной отметки времени.

В ходе оперативного проведения система изменяет время документа таким образом, чтобы очередной документ, проводимый в оперативном режиме, имел бы момент времени более поздний, чем у предыдущего оперативно проведенного документа. Для этого используется понятие оперативной отметки времени. Оперативная отметка получается системой автоматически при оперативном проведении, но может быть получена во встроенном языке в явном виде с помощью метода ПолучитьОперативнуюОтметкуВремени() на основании текущей даты сеанса.
Текущая дата сеанса равна дате компьютера, приведенной к часовому поясу сеанса. Под приведением понимается пересчет местного времени компьютера в поясное время, заданное часовым поясом сеанса. Пересчет выполняется через универсальное координированное время (UTC).
Все пользователи обращаются к единому механизму оперативной отметки времени, а механизм выдает каждому пользователю очередную отметку. Механизм получения оперативной отметки времени обеспечивает получение даты, большей, чем предыдущая отметка, полученная этим или другим пользователем в данном часовом поясе. В качестве оперативной отметки система, как правило, возвращает текущее время сеанса. Однако если текущее время больше или равно последней выданной какому-либо пользователю отметке, то возвращается значение на секунду большее, чем значение последней выданной отметки. Таким образом, обеспечивается получение при каждом обращении значения, по возможности соответствующего текущему времени, но в обязательном порядке большего, чем предыдущее полученное значение.
}//EndRegion "Момент времени и оперативная отметка времени, пояса и прочее"
нумерация документов начнется с 1. Не путать номер и индекс.

Основное отличие отчета от обработки заключается в возможности использования схемы компоновки данных. В остальном обработка не отличается от отчета. У отчета есть возможность использовать по умолчанию схему компоновки данных.

Основное назначение внешнего обработки (отчета) заключается в возможности реализовывать, поставлять и обновлять некоторые возможности отдельно от конфигурации. В этом случае разработка и отладка обработки (отчета) значительно ускоряются: редактирование и сохранение внешней обработки (отчета) выполняются в режиме Конфигуратор, без сохранения конфигурации в целом, а запуск – в режиме 1С:Предприятие. СОВЕТ. Для обеспечения целостности конфигурации внешние обработки (отчеты) рекомендуется использовать в основном в отладочных целях. После отладки алгоритма формирования обработки (отчета) необходимо включить внешнюю обработку в конфигурацию. Для того чтобы использовать внешнюю обработку (отчет) из встроенного языка, необходимо вначале подключить ее с помощью метода Подключить() (доступен только на сервере «1С:Предприятия»). Для программной работы внешняя обработка (отчет) может быть расположена:
	● в файле, который расположен в конфигурации (например, в макете);
	● в данных информационной базы;
	● во временном хранилище (см. здесь).
Имена внешних обработок (отчетов) должны быть уникальны в пределах сеанса. Если осуществляется подключение (программное или интерактивное) внешней обработки (отчета) с именем, повторяющим имя уже загруженной в данном сеансе внешней обработки (отчета), то будет произведено отключение старой обработки и подключение новой.

Планы видов характеристик{
При разработке прикладных решений часто возникают вопросы организации хранения некоторых свойств прикладных объектов, состав и тип которых заранее (на этапе разработки прикладного решения) не известен:
	Список таких свойств (далее будем называть их характеристиками) во время разработки не определен ни по составу, ни по типу хранимых данных. Также возможна ситуация, когда перечень таких характеристик достаточно большой и может быть не востребован каждым пользователем прикладного решения. Следует отметить, что набор характеристик может различаться для разных групп объектов, например, для одной группы элементов номенклатуры используются такие характеристики, как цвет и размер, а для другой - только характеристика, описывающая габаритные размеры. Также следует отметить, что характеристики могут вводиться в процессе эксплуатации сами пользователи системы.
Если для каждой характеристики завести свой реквизит:
	● Каждая характеристика - это отдельное поле таблицы базы данных, которое будет занимать место в базе данных вне зависимости от того, используется характеристика или нет.
	● При большом количестве характеристик количество «лишних» полей будет очень большим, с ними (полями) будет неудобно работать как разработчику, так и пользователю.
	● При необходимости добавить новую характеристику придется дорабатывать прикладное решение: добавлять новый реквизит, везде в прикладном решении учитывать добавленный реквизит. Это трудоемко и неудобно.
Решили использовать специальный объект, в котором описываются характеристики с указанием того, как называется характеристика, какого она типа и т. д. Эта схема лишена недостатков предыдущей: для добавления новой характеристики нет необходимости изменять прикладное решение, не расходуется избыточное место в базе данных. Также имеется возможность самому пользователю добавлять новые характеристики объектов. Система «1С:Предприятие» представляет такой объект. Он называется план видов характеристик.
	поле Тип значения характеристик.-тут План видов характеристик хранит набор типов, которые могут быть указаны для элементов плана видов характеристик (видов характеристик)
	Дополнительные значения характеристик-содержит информацию о возможности создания характеристик, для описания значений которых в информационной базе отсутствуют необходимые объекты.
Ключевым отличием плана видов характеристик от справочника является свойство Тип значения характеристик. Данное свойство описывает перечень типов, которые в дальнейшем могут быть указаны в качестве типа (одного или нескольких) значения конкретного вида характеристики. Возможность такого выбора типа(-ов) не требует изменения структуры и программного кода прикладного решения. Также следует отметить, что для задания типа реквизита, хранящего значение характеристики, связанной с конкретным планом видов характеристик, служит специальный тип Характеристика.<ИмяПланаВидовХарактеристик>. Реквизит, для которого указан такой тип, не может быть составного типа.

Если заполнить свойство реквизита Связь по типу и это свойство следует указать измерение ВидХарактеристики. После указания связи начнет действовать одна из особенностей объекта План видов характеристик: в зависимости от того, какой вид характеристики указан в измерении ВидХарактеристики, система будет автоматически изменять перечень доступных типов для ресурса ЗначениеХарактеристики.


Чтобы использовать в качестве дополнительных значений справочник, надо создать справочник, владельцем назначить план видов характеристик, и в значение характеристики запихнуть справочник.
}//EndRegion "Планы видов характеристик"

Примеры использования Планов видов характеристик{
	1-Сами значения характеристик для конкретных объектов будут храниться в регистрах сведений. Каждый регистр сведений будет хранить информацию о данных, видах характеристик и значениях характеристик одной пары «объект метаданных ‑ план видов характеристик».
	2-Рассмотрим ситуацию, когда пользователю необходимо добавить характеристику, для которой в прикладном решении нет подходящего типа. Например, для номенклатуры необходимо учитывать цвет, а такой справочник в прикладном решении отсутствует. Для реализации такой задачи необходимо создать специальный справочник, который будет являться хранилищем дополнительных значений характеристик. Этот справочник будет являться подчиненным для плана видов характеристик. Затем надо будет указать этот справочник в специальном свойстве плана видов характеристик- Дополнительные значения характеристик. Также этот справочник нужно будет указать в качестве одного из возможных типов свойства Тип значения характеристик.	
	3-Этот пример можно рассмотреть при необходимости использовать для описания видов характеристик всех объектов метаданных один план видов характеристик, а для хранения значений характеристик использовать один регистр сведений. Разделение видов характеристик между объектами метаданных будет выполняться с помощью реквизита плана видов характеристик. Значение этого реквизита будет определять «принадлежность» конкретному объекту (реквизит содержит значение) или всем объектам метаданных (реквизит не задан).
	4-Если доступ к характеристикам и их значениям должен ограничиваться с помощью ограничений доступа к данным (см. здесь), наложенным на сам объект (например, пользователь может изменять характеристики товара только тогда, когда он может изменять сам товар), то можно воспользоваться хранением характеристик (и их значений) в табличных частях справочников, документов и других объектов, для которых доступно создание табличных частей.
}//EndRegion "Примеры использования Планов видов характеристик"
	
logical REGISTERS сведений{
	Единицей хранения информации в регистрах является запись. Прикладная нагрузка записи регистра определяется исключительно хранящимися в ней данными. Например, сама запись о курсе валюты не представляет собой ничего существенного. Она не соответствует никакому объекту в предметной области. Существенным является только то, что в ней содержится валюта, дата и курс валюты, установленный на эту дату. Можно удалить эту запись и внести такую же - это не повлияет на логику работы системы. Соответственно, у записей регистров не существует ссылок, и в полях базы данных нельзя хранить ссылки на записи регистров.
	
	Основная задача регистра сведений - хранить существенную для прикладной задачи информацию, состав которой развернут по определенной комбинации значений и при необходимости развернут во времени. Например, если мы хотим хранить информацию о ценах конкурентов на продаваемые нами товары, то собранная информация о ценах разворачивается по товарам и конкурентам. А если мы хотим отслеживать динамику изменений цен и будем заносить их периодически, то хранимая информация разворачивается также и во времени.
	
	Регистр сведений фактически представляет собой в общем случае многомерный массив данных, необходимый для реализации функции, которая может выдать нужную информацию по определенному набору аргументов. Аргументы функции называются измерениями, а результат функции - ресурсами. В приведенном выше примере двумерный регистр ЦеныКонкурентов будет содержать измерения Конкурент и Товар и ресурс Цена. Ресурсов может быть больше чем один: например, можно хранить оптовую и розничную цены.
	
	Регистры сведений, информация в которых развернута во времени, называются периодическими. Для периодических регистров сведений система поддерживает такие стандартные операции, как получение наиболее позднего или наиболее раннего значения (например, получение последней введенной цены по конкретному товару и конкретному конкуренту), а также получение среза наиболее поздних или ранних значений. Например, могут быть получены все последние введенные цены по различным товарам и конкурентам.
	
	Для разворота информации во времени используется поле Период регистра. Оно не вносится в качестве измерения, а добавляется системой автоматически при создании периодического регистра.
	
	Для регистров сведений можно не создавать измерений. В этом случае регистр будет представлять набор периодических данных. Такие регистры могут использоваться, например, для хранения фамилий различных должностных лиц, чьи подписи располагаются в документах. В процессе ведения хозяйственной деятельности документы создаются и подписываются должностными лицами, имеющими право подписи в определенный момент времени. Можно использовать для этого и константы, но есть проблема: в случае смены значения константы является то, что при открытии архивного документа будет указана новая фамилия ответственного лица, выбранная из константы. В таких случаях нужно использовать не константу, а периодический регистр сведений, который хранит данные об изменениях, а в документах используется выбор значений из регистра сведений по дате документа.
	
	Наиболее характерный пример одномерной периодической величины ‑ курс валюты. При выполнении каких-либо расчетов (например, при определении рублевой цены пересчетом валютной цены по курсу) важно знать его величину на момент вычисления. Особенно важно знать курс валюты при выполнении каких-либо расчетов задним числом в этом случае необходимо «вспоминать» курс за уже прошедшие даты.
	
	Если регистр непериодический, то поле Период для него не создается. В приведенном примере регистр ЦеныКонкурентов может быть непериодическим, если мы не хотим хранить историю изменения цен, а хотим иметь только актуальные цены. Тогда функция регистра сможет ответить на вопрос: «Какая сейчас цена у такого-то конкурента на такой-то товар», но не сможет ответить на вопрос: «Какая была цена у такого-то конкурента на такой-то товар в начале года».
	Из описанных принципов работы регистра сведений вытекает то, что в системе может быть только одна запись с определенным набором и периодом измерений. Действительно, по одному товару одного конкурента может быть только одна цена. Если по какой-либо причине мы можем получить несколько цен и хотим занести эту информацию в базу данных, то нам нужно создать еще одно измерение для хранения того значения, по которому эти цены могут различаться. Например, можно завести измерение ИсточникИнформации. Тогда можно будет вводить цены конкурентов в разрезе источников.
	Уникальность записей по набору измерений принципиально отличает регистры сведений от регистров накоплений, которые позволяют вводить несколько записей с одинаковым значением измерений и периодом.
	
	Регистры, записываемые независимо, могут свободно редактироваться вручную или средствами встроенного языка. При этом если измерение такого регистра назначено как «ведущее» и значением измерения является ссылка на объект базы данных, то будет считаться, что запись регистра имеет смысл, только пока существует этот объект. Например, если назначить ведущим измерение Конкурент, то считается, что запись имеет смысл только как информация по данному конкуренту. Соответственно, при удалении данных конкурента записи по нему будут удалены автоматически.
	Если измерение будет "ведущее", то у ведущее можно будет открывать через панель навигации. Допустим сделаем измерение справочника ведущим, и в форме справочника по умолчанию сможем открывать регистр сведений.
	
	Если регистр записывается регистратором, то это значит, что записи будут жестко подчинены регистраторам - документам. Обычно это значит, что записи будут порождаться при проведении документов. Соответственно, при удалении документа записи будут удаляться автоматически. В отличие от ведущих измерений, регистратор может быть только один.
	
	Периодичность - это свойство позволяет указать, с какой периодичностью регистр должен сохранять значения ресурсов.
	Это свойство напрямую влияет на возможность получения значений ресурсов регистра методами встроенного языка. Для непериодического регистра можно получить только последнее введенное значение ресурсов регистра - информация за предыдущие периоды в таком регистре отсутствует. Для периодических регистров нельзя получить значение с меньшей периодичностью, чем установленная периодичность регистра.
	Периодичность не зависит от способа редактирования регистра.
	
	Режим записи - свойство определяет, каким образом будут вноситься записи: независимо (например, вручную) или будут подчиняться регистратору (например, документами).
	Если для регистра указано, что он периодический и выбран независимый режим записи, то становится доступным свойство Основной отбор по периоду. Если флажок установлен, то наряду с основными измерениями и реквизитами регистра, участвующими в отборе записей при регистрации изменений, можно указывать отбор по полю Период.
	На закладке Регистраторы производится управление списком регистраторов. Закладка доступна, если в свойстве Режим записи установлено Подчинение регистратору.
	
	
	Основное назначение регистров сведений - хранить информацию НЕ ссылочного типа в разрезе комбинации измерений и, как частный случай, хранить изменяемые во времени значения. По большому счету, в регистре можно хранить что угодно, но получить ссылку на саму запись регистра и сохранить её (ссылку на запись) в реквизитах другого объекта, например справочника, уже не получится.
	Регистр сведений на уровне СУБД представляет собой обычную плоскую таблицу, в которой колонки это наши измерения, ресурсы и реквизиты, а строки - записи регистра. 
	
	Если при работе с регистром получение данных на самый первый или самый последний (текущий) моменты времени являются наиболее частыми вариантами использования, то для таких регистров имеет смысл разрешить системе поддерживать итоги для среза последних (свойство Разрешить итоги: срез последних) или среза первых (свойство Разрешить итоги: срез первых)- при создании переодического регистра сведений, во вкладке прочие, станут активными срез первых и срез последних.
	
	Строки регистра сведений, содержащие информацию о значениях ресурсов для определенных значений измерений и конкретного периода, называются записями. Для идентификации записи регистра сведений служит ключ записи.
	
	Ведущее - установка этого свойства имеет смысл для измерений, тип данных которых - ссылка на объект конфигурации. В этом случае считается, что запись регистра сведений имеет смысл, только пока существует этот объект. При удалении объекта записи по нему будут автоматически удалены из регистра.
	
Своими словами{	
Если регист записи непереодический:
И в установлено:  режим записи "Независимый", тогда чтобы перезаписать значение, нужно использовать менеджерЗаписи. Суть в том, что ты создать лапками можешь элемент реквизита, если измерение уникальное и по такому измерению нет ничего. Если что-то уже по такому измерению есть, то даже открыть форму не сможешь, а при создании нового выдаст ошибку. А используя менеджер записи ты или создашь новое, или перезаписываешь старое. То что было раньше у непереодического не сохраняется.
	МенеджерЗаписи=РегистрыСведений.РегистрСведений1.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Измерение1=77;
	МенеджерЗаписи.цена=ТекущаяДата();
	МенеджерЗаписи.Записать();
	
А если регист подчинен регистратору:
режим записи "Подчинение регистратору" тогда к этого например документа можно написать:
	Движения.РегистрСведений2Подчиненный.Записывать = Истина;
	Движение = Движения.РегистрСведений2Подчиненный.Добавить();
	Движение.Ресурс1 = ТекущаяДата();
И каждый раз при проведении документа, значение перезаписывается. Новые движения не создаются. Просто одно и тоже перезаписывается.
А если регист переодический и подчиненный регистратору, допустим по дню тогда:
	Движения.РегистрСведений2Подчиненный.Записывать = Истина;
	Движение = Движения.РегистрСведений2Подчиненный.Добавить();
	Движение.Период = Дата;//добавилась дата.
	Движение.Ресурс1 = ТекущаяДата();
и если ты в течении дня переведешь его, то он перезапишется.


У измерения есть свойство ведущее-это документ будет типо регистратором, у НЕЗАВИСИМОГО регистра сведений, создаешь измерение ведущее на док1 и ручками создаешь запись, где измерение1 равно документ1 под номером 005, и при удалении документа номер 005, запись сама удалиться, как если б документ1 был бы регистратором, а если регист будет ПодчиненРегистраторому, допустим докумет2, то удаляй, не удаляй, толку не будет. Смысл есть только для независимого.
Можно поставить хоть пять ведущий измерения-проблем с этим нет, но при удалении любого объекта, на которые ссылаются ведущие измерения, запись удалиться, хотя остальные четыре измерения будут существововать.
	}//EndRegion "Своими словами"
	
}//EndRegion "registr"

регистр накопления{
	Регистр накопления - это объект конфигурации, предназначенный для хранения движений регистра и итоговой информации. Методы встроенного языка позволяют получить остатки регистра накопления на заданный момент времени.
	Движения регистров содержат только приращения (со знаком плюс или минус) значений ресурсов регистра, а не итоговые величины значений.
	Движения регистров оказывают влияние на его итоги. Итоги  это сводная информация регистров, которая получается путем суммирования значений, вносимых движениями регистров.
	В системе «1С:Предприятие» возможно использование регистров накопления двух типов: регистры остатков и регистры оборотов.
	Для регистра остатков методы встроенного языка позволяют получить остатки регистра накопления на заданный момент времени. Есть возможность фильтрации по значениям измерений, а также получения остатков в разрезе других измерений.
	Регистры оборотов предназначены для хранения информации, для которой понятие остатка лишено смысла, например, сумм продаж в разрезе покупателей.
	
	Разрешить разделение итогов - если флажок установлен в значение Истина (значение по умолчанию), то будет задействован механизм разделителя итогов, который обеспечивает более высокую параллельность работы при записи в регистр. При одновременной записи движений несколькими сеансами система не будет обновлять одни и те же записи итогов, а будет записывать изменения итогов отдельно. При получении итогов эти данные складываются. Таким образом, обеспечивается и поддержание в актуальном состоянии итогов (для быстрого получения отчетов, например), и параллельность записи движений. Этот режим требует дополнительных расходов ресурсов (например, увеличивается количество данных в итоговых таблицах).
}//EndRegion "регистр накопления"

ПоказатьОповещениеПользователю(){
Есть процедура:
ПоказатьОповещениеПользователя(<Текст>, <ДействиеПриНажатии>, <Пояснение>, <Картинка>, <СтатусОповещенияПользователя>, <КлючУникальности>) 
Если оповещение будет СтатусОповещенияПользователя.Важное то его можно будет потом после исчезновения увидеть в 
}

Если в элемент формы Группа вида Страницы пользователь добавит страницу, то при переходе на эту страницу свойство группы ТекущаяСтраница станет равно Неопределено. Свойство формы ТекущийЭлемент также будет содержать значение Неопределено в том случае, когда активным элементом формы является элемент, добавленный пользователем.	

}//EndRegion "outlook word remarks"

description technical{
Для отказа от изменений в конфигурации достаточно выбрать пункт Конфигурация – Конфигурация базы данных – Вернуться к конфигурации БД.
Перейти (Goto) Перейти <Метка>; Не может запрыгнуть внутрь цикла, или за пределы функции и процедуры (в другую функцию)
Конструкции Попытка – Исключение – КонецПопытки могут быть вложенными, В выдаче диагностики помощь могут оказать встроенные функции ОписаниеОшибки() и ИнформацияОбОшибке().
Обращение к свойствам объектов: Помимо основного обращения через точку, в языке системы «1С:Предприятие» предусмотрен механизм обращения к свойствам объектов по строке с именем свойства с помощью оператора [] (квадратные скобки).
<Объект>[<Имя свойства>]
	Спр["Наименование"];
	Спр.Наименование;
В языке есть возможность при обращении к объектам и формам извне, из других программных модулей, обращаться к переменным, процедурам и функциям этих модулей, как к свойствам и методам самих объектов и форм. Можно обращаться к тем переменным, процедурам и функциям, которые объявлены с ключевым словом Экспорт. Для форм дополнительно возможно обращение к реквизитам формы.{
Пример:

// Пример использования процедуры печати документов из журнала
// документов. Допустим, у нас есть несколько различных документов,
// причем у всех есть процедура Печать(). В модуле журнала
// документов располагается кнопка "Печать", которая
// вызывает процедуру печати текущего документа журнала.
Процедура ПечатьНажатие(Элемент)
    // Получим текущий документ, на котором установлен курсор.
    ТекДок = ЭлементыФормы.ЖурналСписок.ТекущаяСтрока;
    // Получим основную форму текущего документа.
    ФрмТекДок = ТекДок.ПолучитьФорму();
    // Вызовем процедуру печати, расположенную
    // в модуле формы документа.
    ФрмТекДок.Печать();
КонецПроцедуры
}//EndRegion "при обращении к объектам и формам извне"

Если вызов происходит без передачи управления между клиентом и сервером (вызов происходит только на клиентской или только на серверной стороне), то по умолчанию параметры передаются по ссылке. При этом изменение формального параметра ведет к изменению соответствующего фактического параметра. С помощью модификатора Знач перед именем формального параметра можно указать, что параметр передается по значению. В этом случае нельзя изменить значение фактического параметра путем присвоения формальному параметру какого-либо значения.{
	
&НаКлиенте
Процедура МояПроцедура()
    А = 100;
    ПоСсылке(А);
    // Переменная А = 40, так как в теле процедуры значение
    // параметра Параметр1 изменено на 40.
    // Изменение переменной А произошло потому, что параметр передавался по ссылке
    А = 100;
    ПоЗначению(А);    
    // Переменная А = 100, несмотря на то, что в в теле процедуры
    // значение параметра Параметр1 изменено на 40.
    // Изменение переменной А не произошло, так как параметр передавался по значению
КонецПроцедуры
&НаКлиенте
Процедура ПоСсылке(Параметр1)
    Параметр1 = 40;
КонецПроцедуры
&НаКлиенте
Процедура ПоЗначению(Знач Параметр1)
    Параметр1 = 40;
КонецПроцедуры
}//EndRegion "Вызов без передачи управления с клиента на сервер"
Однако необходимо помнить следующую особенность: если параметром передается агрегатный объект, то невозможно присвоить фактическому параметру другое значение, но возможно изменить сам переданный объект. Например, если в процедуру по значению передан массив, то можно очистить этот массив методом Очистить(), но нельзя изменить в вызывающей процедуре само значение параметра.{
&НаКлиенте
Процедура МояПроцедура()
    Массив = Новый Массив;
    Массив.Добавить(12);
    Массив.Добавить(18);
    // В массиве есть два элемента
    ПоЗначению(Массив);
    // Массив пустой, но это по-прежнему массив, а не Число
КонецПроцедуры
// Параметр передается по значению
&НаКлиенте
Процедура ПоЗначению(Знач Параметр)
    // В массиве два значения
    Параметр.Очистить();
    // В массиве нет значений!
    // Меняем формальный параметр
    Параметр = 14;
    // Изменено значение только формального параметра
КонецПроцедуры
//Сам массив не изменить, а вот из него все указатели можно поудалять.
}//EndRegion "Объекты в памяти и массив."
Присваивание такого массива, это ссылка на массив, осторожно с сылками{
&НаКлиенте
Процедура ТестоваяПроцедура()
    ЗначениеА = Новый Массив;
    ЗначениеА.Добавить(1);
    ЗначениеА.Добавить(2);
    ЗначениеБ = ЗначениеА;
    // обращение к любой переменной: ЗначениеА или ЗначениеБ вызывает
    // изменение одного и того же масива
    МояПроцедура(ЗначениеА, ЗначениеБ);
    // После завершения вызова процедуры обе переменные (ЗначениеА и ЗначениеБ)
    // ссылаются на один массив.
    // В массиве находятся следующие значения:
    // ЗначениеА[0] = ЗначениеБ[0] = "А"
    // ЗначениеА[1] = ЗначениеБ[1] = "Б"
КонецПроцедуры
&НаКлиенте
Процедура МояПроцедура(Параметр1, Параметр2)
    // Несмотря на то, что параметров два, фактически работа происходит с одним массивом
    Параметр1[0] = 5;
    Параметр1[1] = 6;
    Параметр2[0] = "А";
    Параметр2[1] = "Б";
КонецПроцедуры	
//В данном примере следует обратить внимание на тот факт, что операция присваивания ЗначениеБ = ЗначениеА; (в процедуре ТестоваяПроцедура()) не приведет к созданию копии массива, который находится в переменной ЗначениеА. Обе переменные будут ссылаться на один и тот же массив!

//При этом в процедуру МояПроцедура() параметры передаются по ссылке, следовательно, при изменении двух разных формальных параметров происходит изменение одного физического массива.
}//EndRegion "операция присваивания не всегда приводит к созданию копии"

Память и передача параметров по ссылке на сервер и обратно{Вызов процедур и функций с передачей управления между клиентом и сервером характерен тем, что в общем случае при таком вызове изменяется компьютер, на котором происходит работа вызываемого метода. Это происходит потому, что клиент работает на одном компьютере, а сервер – на другом. Следовательно, нельзя говорить о передаче параметров по ссылке, т. к. один компьютер не может получить прямого доступа к памяти другого компьютера. При работе в файл-серверном варианте клиент и сервер представляют собой один компьютер, но на логику взаимодействия это не влияет. Поэтому передача параметров в случае клиент-серверного взаимодействия происходит особым образом:
	● При передаче управления с клиента на сервер (и обратно) всегда передаются копии параметров. При вызове серверной процедуры или функции с клиента происходит создание копии фактического параметра и передача этой копии на сторону сервера. При возврате управления с сервера на клиента также происходит создание копии формального параметра (с которым происходила работы в вызванной процедуре или функции) для передачи обратно на клиента.
	● Если формальный параметр указан с модификатором Знач, то значение параметра будет передаваться только при вызове процедуры или функции и не будет передаваться обратно при возврате управления на клиента.
	● Если для нескольких формальных параметров указывается одно и то же фактическое значение, то создается столько копий фактического значения, для скольких формальных параметров используется значение.
	● Если в качестве формальных параметров указано значение одной и той же переменной, то после возврата управления с сервера значение этой переменной будет установлено в значение самого правого формального параметра (без модификатора Знач), который изменялся в вызываемой функции.
}//Память и передача параметров по ссылке на сервер и обратно

Если на сервер передасть структуру, у которой значения массивы, то передастся на сервер копия структуры:  Такое поведение будет обусловлено тем, что при вызове процедуры происходит создание копии не только самого параметра (переменная Структура), но и всех объектов, находящихся в этой структуре://{ два массива, которые изначально указывали на один массив со значениями элементов «0» и «1».
	&НаКлиенте
Процедура ТестоваяПроцедура(Команда)
    ЗначениеА = Новый Массив;
    ЗначениеА.Добавить(1);
    ЗначениеА.Добавить(2);
    ЗначениеБ = ЗначениеА;
    Структура = Новый Структура("Ключ1, Ключ2", ЗначениеА, ЗначениеА);
    СервернаяПроцедура(Структура);
    ЗначениеА[0] = 9;
    ЗначениеА[1] = 8;
    ЗначениеБ[0] = "C";
    ЗначениеБ[1] = "D";
КонецПроцедуры
&НаСервере
Процедура СервернаяПроцедура(Параметр1)
 Параметр1.Ключ1[0] = "0";
 Параметр1.Ключ1[1] = "1";
 Параметр1.Ключ2[0] = "2";
 Параметр1.Ключ2[1] = "3";
КонецПроцедуры
После завершения вызова процедуры ТестоваяПроцедура() будет наблюдаться следующее состояние переменных:

● Массивы ЗначениеА и ЗначениеБ идентичны и содержат значения «С» в первом элементе и значение «D» во втором элементе, т. к. переменная ЗначениеБ указывает на массив из переменной ЗначениеА и значения этих переменных не передавались на сервер.

● В переменной Структура будут находиться два массива:

● Со значениями «0» и «1» для элементов массива, находящегося в элементе структуры с ключом Ключ1.

● Со значениями «2» и «3» для элементов массива, находящегося в элементе структуры с ключом Ключ2.

● Такое поведение будет обусловлено тем, что при вызове процедуры происходит создание копии не только самого параметра (переменная Структура), но и всех объектов, находящихся в этой структуре: два массива, которые изначально указывали на один массив со значениями элементов «0» и «1».
	
}//КонецОбласти "Передача структуры на сервер"

Опущенные и пропущенные параметры{
При передаче параметров в метод (процедуру или функцию) различаются две ситуации: когда параметр опущен и когда параметр пропущен. Пропущенный параметр – это параметр, значение которого явным образом не указано. Если пропускается несколько параметров, то в строке с вызовом метода каждый из пропускаемых параметров должен быть отмечен «своей» разделительной запятой.
Процедура МояПроцедура(Параметр1, Параметр2)
…
КонецПроцедуры
// Параметр Параметр1 – пропущен
МояПроцедура( ,1);

Опущенным может быть только один или несколько параметров, указанных справа в списке формальных параметрах при описании метода. При этом опускать можно только параметры, которые имеют значение по умолчанию. Если опущеными будут пармаетры, не имеющие значений по умолчанию, то при компиляции данного программного кода будет выдана ошибка о несоответствии числа параметров. Значение опущенного параметра (одного или нескольких) определяется значениями по умолчанию для опускаемых параметров. Значение пропускаемого параметра равно значению по умолчанию (если таковое задано) или значению Неопределено, если для формального параметра не задано значение по умолчанию.
Процедура МояПроцедура(Параметр1, Параметр2 = "по умолчанию", Параметр3 = 16)
…
КонецПроцедуры
// Параметр Параметр1 пропущен, значение параметра = Неопределено
// Параметр Параметр2 указан, значение параметра = 1
МояПроцедура( ,1);
// Параметр Параметр1 пропущен, значение параметра = Неопределено
// Параметр Параметр2 пропущен, значение параметра = "по умолчанию"
// Параметр Параметр3 опущен, значение параметра = 16
МояПроцедура(, ,);
// Ошибка несоответствия количества параметров
МояПроцедура();
}//EndRegion "Опущенные и пропущенные параметры"
При передаче с клиента на сервер и обратно строковых значений следует помнить, что эти значения не должны содержать символы, недопустимые с точки зрения спецификации XML версии 1.0.
СОВЕТ. На стороне сервера такую проверку можно выполнить с помощью функции НайтиНедопустимыеСимволыXML().

Использование номеров и индексов{
	В языке системы «1С:Предприятие» есть ряд объектов, отдельные части которых имеют нумерацию. К таким объектам, например, относится строка, символы которой имеют номер в строке, или табличный документ, строки и колонки которого имеют номер, и т. п. При обращении к частям объектов обычно используется понятие Номер. Номера начинаются с 1.
	При обращении к элементам коллекций используется понятие Индекс. Индексирование элементов коллекций начинается с 0.
}//EndRegion "Использование номеров и индексов"

В связи с тем, что на стороне клиента недоступны прикладные объекты, получение предопределенных реквизитов с помощью менеджеров объектов становится невозможным. Поэтому для их получения существует метод глобального контекста ПредопределенноеЗначение(). Параметром этого метода является строка, описывающая то, какое предопределенное значение требуется получить.

Синхронные и асинхронные методы работы{
При работе с объектами, которые реализуют некоторую, достаточно специфичную (работа с файлами, блокирующими окнами, криптографией и внешними компонентами), функциональность, можно выделить два различных подхода: синхронный и асинхронный. Отличие в этих подходах определяется их названиями.

При синхронном подходе вызов какого-либо метода объекта приведет к тому, что работа вызывающего кода будет остановлена до тех пор, пока не завершится вызов метода объекта (со всеми вложенными вызовами). Обычный вызов процедуры или функции встроенного языка является синхронным вызовом.

При асинхронном подходе вызов метода объекта выполняется как обычно, но управление сразу возвращается вызывающему коду и его исполнение продолжается. При этом вызванный метод гарантирует, что после завершения своей работы он оповестит о своем завершении заинтересованное «лицо» (если такое оповещение требуется). Оповещение выполняется с помощью вызова специального метода, который передается в вызываемый метод объекта. Все вышеописанное верно только для тех методов, для которых заявлена поддержка асинхронной работы.

Для описания оповещения используется специальный объект ОписаниеОповещения. При его создании необходимо указать имя процедуры оповещения, место ее (процедуры) расположения и дополнительные параметры, если необходимо. Дополнительные параметры могут использоваться процедурой обработки оповещения для своей работы. В приведенном выше примере дополнительные параметры не указываются.

Также следует отметить, что процедуры обработки оповещений (обратного вызова) могут располагаться только на стороне клиентского приложения в модуле формы, общем модуле и модуле команды. Процедура обратного вызова должна быть описана с ключевым словом Экспорт.
}//EndRegion "Синхронные и асинхронные методы работы"

Ввод по строке{
В качестве реквизитов, по которым будет выполняться поиск, могут выступать:
		● Для документов – Номер.
		● Реквизиты, имеющие тип Число или Строка, для которых свойство Индексировать имеет значение Индексировать или Индексировать с доп. упорядочиванием. Примером последних может служить поле для ввода артикула, штрихкода, ИНН.
Для формирования списка реквизитов нужно нажать кнопку выбора и в открывшемся диалоге перенести в левый список те поля, по которым может производиться ввод по строке. Это в свойствах документа в группе ввод по строке.
Свойство Режим получения данных выбора управляет тем, как платформа осуществляет поиск данных при вводе по строке. Если свойство установлено в значение Фоновый, то для получения данных используется фоновое задание, а в выпадающем списке отображается анимированная картинка, аналогичная фоновому выполнению отчета.


}//EndRegion "Ввод по строке"
Программное формирование списка выбора{
Если разработчика не устраивает, каким образом формируется список выбора, он может переопределить его самостоятельно.
Сделать это можно двумя способами:
	● Непосредственно в форме – в этом случае особое формирование списка выбора будет работать только для этого, единственного поля. Для этого необходимо определить обработчики событий НачалоВыбора, АвтоПодбор и ОкончаниеВводаТекста.
	● В модуле менеджера соответствующего объекта – в этом случае особое формирование списка выбора будет выполняться для всех полей ввода, в которых вводятся значения используемого объекта.
Для программного формирования списка выбора необходимо переопределить обработчик события ОбработкаПолученияДанныхВыбора менеджера объекта. 
}//EndRigion "Программное формирование списка выбора"

Существует возможность заполнения реквизитов новых объектов при интерактивном создании (кроме копирования), при вводе на основании, при использовании методов ОткрытьФорму()/ПолучитьФорму() или при явном вызове метода Заполнить(){//хуйня какая-то.
В общем создаем документ и команду. У документа реквизиты: реквизит1,реквизит2,реквизит3.
ДЛЯ КАЖДОГО РЕКВИЗИТА, именно кликаем по каждому реквизиту и ставим галочку "заполнять из данных заполнения", если не поставить, то и заполняться они не будут.
В команде прописываем:
		&НаКлиенте
		Процедура ОбработкаКоманды(ПараметрКоманды, ПараметрыВыполненияКоманды)
			ЗначенияЗаполнения = Новый Структура;
			ЗначенияЗаполнения.Вставить("Реквизит1","йцу1");
			ЗначенияЗаполнения.Вставить("Реквизит2","2");
			ЗначенияЗаполнения.Вставить("Реквизит3","йц3");
			
			ПараметрыФормыДляЗаполнения = Новый Структура;
			ПараметрыФормыДляЗаполнения.Вставить("ЗначенияЗаполнения",ЗначенияЗаполнения);	
			ОткрытьФорму("Документ.Документ1.ФормаОбъекта", ПараметрыФормыДляЗаполнения);
		КонецПроцедуры
и при нажатии на команду, будет открываться форма создания документа, где реквизиты заполнены. Если допустим вставлять параметр формы не "ЗначенияЗаполнения", а например "НеЗначенияНеЗаполнения"

Еще один вариант:
	У документа есть процедура "ОбработкаЗаполнения". В МодулеОбъекта создаем &НаСервере Процедура ОбработкаЗаполнения(ДанныеЗаполнения, ТекстЗаполнения, СтандартнаяОбработка) главное на сервере. Она будет вызываться, в некоторых случаях-например в документе создадим команду, которая вызывает:
		&НаСервере
		Процедура НеМогуВТонкомКлиенте()
			ДокОб=Объект.Ссылка.ПолучитьОбъект();	
			сообщить(ДокОб);
			Зап=Новый Структура;
			Зап.Вставить("Реквизит1","3459");
			ДокОб.Заполнить(Зап);
		КонецПроцедуры;
И строка "ДокОб.Заполнить(Зап);" вызовет стандартную обработку "ОбработкаЗаполнения".

}//"Заполнение"

У ссылочного реквизита, если такого объекта нет, есть кнопка СОЗДАТЬ{//при открытии формы передать в нее нужные данные заполнения
У форм есть много стандартных реквизитов - ЭтаФорма.Параметры.ТекстЗаполнения и другие. В параметр ТекстЗаполнения помещается введенное в реквизит. Так же у реквизита есть свойство параметры выбора-то что туда запихнется появиться у ЭтаФорма.Параметры.ПараметрыВыбора и эти параметры можно обработать при создании формы на сервере у создаваемого объекта. Связи параметров выбора тоже учитываются. Так можно создавать заполняя новые объекты.
	Параметры выбора – данное свойство позволяет указать значения параметров, которые будут применяться при выборе значения реквизита. Параметры выбора будут выполняться при открытии формы выбора, при отображении списка быстрого выбора и при выполнении ввода по строке. 
	
Открывая форму программно, можно передать ей набор данных заполнения, который она получила бы, если бы открывалась интерактивной командой.
	Например, программно нужно открыть форму новой накладной точно так, как если бы она открывалась интерактивной командой из списка накладных, отобранного по поставщику и складу. Предположим, что в переменных СсылкаНаПоставщика и СсылкаНаСклад у нас имеются необходимые ссылки. Тогда можно использовать следующий код:
		ЭлементыОтбора = Новый Структура("Поставщик, Склад", СсылкаНаПоставщика, СсылкаНаСклад);
		ПараметрыФормы = Новый Структура("ЗначенияЗаполнения", ЭлементыОтбора);
		ОткрытьФорму("Документ.Накладная.ФормаОбъекта", ПараметрыФормы); 
	Можно создать программно объект, а затем вызвать его метод Заполнить(). В этом случае платформа выполнит все те же действия и вызовет все те же события, которые она бы вызвала в случае интерактивного создания нового объекта. В метод Заполнить() в качестве параметра точно так же можно передать структуру, содержащую данные заполнения:
		ЭлементыОтбора = Новый Структура("Поставщик, Склад", СсылкаНаПоставщика, СсылкаНаСклад);
		ОбъектНакладной = Документы.Накладная.СоздатьДокумент();
		ОбъектНакладной.Заполнить(ЭлементыОтбора);
		// Действия, имитирующие интерактивный ввод данных пользователем
		...
		ОбъектНакладной.Дата = ТекущаяДатаСеанса();
		...
		ОбъектНакладной.Записать();
}//EndRegion "У ссылочного реквизита, если такого объекта нет, есть кнопка СОЗДАТЬ"

У реквизитов появились свойства Связи параметров выбора и параметры выбора. Они предназначены для настройки формы выбора без использования кода.{
	Они предназначены для настройки формы выбора без использования кода. Если кратко то, Связи параметров выбора настраивают отбор в открываемой форме на основе реквизитов текущего объекта, а Параметры выбора - настраивают отбор на основе жестко установленных значениях
	
Связи параметров выбора{
У реквизита можно создать связи параметров выбора. Там две колонки: 
Отбор.Реквизит3 и реквизит1.
Это значит, что в списке выбора будут те договора2, у которых реквизит3 равен реквизит1 этого договора. Меняем в этой же форме реквизит1 и смотрим-совсем другие договора в списке выбора появились.

Значения, указанные в данном свойстве, будут переданы в открываемую форму через структуру Параметры. При этом значение колонки Имя будет соответствовать ключу элемента структуры, а значение реквизита, указанное в колонке Реквизит, – значению элемента структуры. Если в колонке Имя указано значение вида Отбор.Владелец, то будет создан параметр формы Отбор (типа Структура). В этой структуре будет создан элемент с ключом Код и значением, полученным из реквизита, указанного в колонке Реквизит.

"Также в окне редактирования связей параметров выбора можно задать режим очистки поля при изменении полей связи. Если значение свойства Режим изменения связанного значения равно Очищать, то поле будет очищено при интерактивном изменении значения связи (изменением считается также повторный выбор значения, ранее находившегося в поле) до наступления события ПриИзменении. В противном случае (значение свойства равно Не изменять) поле не будет очищено. Очистка происходит вне зависимости от реального изменения значения в элементе связи и выполняется до вызова обработчика события ПриИзменении. "-не понял, как это вообще работает. Даже создав свою форму выбора, установив решим независимый, она открывается поверх как модальная и блокирует все. Как интерактивно изменить непонятно.-понял.  Режим изменения = Очищать, означает, что при очистке реквизита Контрагент очиститься и реквизит Договор, т.е. реквизит свойства которого мы настраиваем. Уже после выбора, если поменять что-либо, другое очиститься. Гениально.
}//EndRegion "Связи параметров выбора"

Параметры выбора – данное свойство позволяет указать значения параметров, которые будут применяться при выборе значения реквизита. Параметры выбора будут выполняться при открытии формы выбора, при отображении списка быстрого выбора и при выполнении ввода по строке. 
Если имя у какого-либо параметра свойства Связи параметров выбора (см. здесь) совпадает с именем какого-либо параметра свойства Параметры выбора, то приоритет отдается элементу из свойства Связи параметров выбора (параметр из свойства Параметры выбора игнорируется).

}//EndRegion "Связи параметров выбора и параметры выбора."

Последовательности документов{
Создам в тестовой:
	Поступление-его реквизит ПостСумма идет в регист накопления ПостСумма
	Реализация входит в последовательность и обработка проведения сообщает номер.
	последовательность Последовательности в которой находиться Реализация и зависит от регистра ПостСумма
и создал ОбщаяКоманда в которой сообщить(Последовательности.Последовательность1.ПолучитьГраницу());	
В общем при создании документа поступления прошлым месяцом, граница сдвигается на него. И в ВсеФункции - Стандартные - ПроведениеДокументов - Проведение последовательностей, если выбрать Восстановить, проведутся все документы с этой границы.

Движения, влияющие на последовательность – одно из основных свойств последовательности. Оно определяет, какие из движений будут влиять на необходимость перепроведения документов данной последовательности, то есть движения или итоги каких механизмов учета используются документами данной последовательности при проведении. Например, в качестве таких движений могут выступать движения регистров. Для настройки данного параметра следует добавить в список те виды регистров, движения которых будут нарушать данную последовательность.
Если для последовательности не создано ни одного измерения, то при восстановлении данной последовательности будут перепроводиться все входящие документы. Если требуется, чтобы данная последовательность учитывала не все, а вполне определенные ситуации, то в последовательность включают измерение. В этом случае перепроводить нужно будет только те документы, которые изменяют состояние регистра с учетом свойств измерения.

В общем можно добавить измерение-это ссылка допустим на справочник. У регистра создаем ссылку на справочник и у документа создаем реквизит ссылку на справочник. И будут перепроводиться только те, которые меняют этот этот справочник:
	Создадим элемент1 и элементDivideSecond
	Док1- 01месяц элемент1
	Док2- 02месяц элементDivideSecond
	Док3- 03месяц элемент1
	Док4- 04месяц элементDivideSecond
	Док5- 05месяц элемент1
	Док6- 06месяц элементDivideSecond
И два документа, которые идут годом меньше, тем те доки. У Первого будет элемент1 а у второго элементDivideSecond.
Восстанавливаем последовательность, и граница на Док6. Потом проводим Второй и восстанавливаем границу:
провелись Док2,4.6. Граница сново на шестом.Проводим Теперь первый и граница на нем, восстанавливаем: Док1,3,5. и граница на пятом. Провелись только те, у которых элемент1, а последний с элементDivideSecond, проведем еще раз и провелся шестой. Повторю: Да, надо и во второй раз проводить.

Документы, основывающиеся при проведении на данные итогов, должны проводиться строго последовательно. То есть все документы, анализирующие остатки и расположенные после измененного документа, должны быть перепроведены. Для автоматического контроля необходимости перепроведения документов используются объекты ветви Последовательности. 


}//EndRegion "Последовательности документов"

История изменений справочника{
Просто перед записью справочника сравнивает ЭтотОбъект с значением реквизита. Если они разные, то что-то делаем.
Процедура ПередЗаписью(Отказ)
	сообщить(ЭтотОбъект["Реквизит1"]);
	сообщить(Ссылка["Реквизит1"]);
	Сообщить(ЭтотОбъект["Реквизит1"] <> Ссылка["Реквизит1"]);
КонецПроцедуры
}//КонецОбласти "История изменений справочника"

Расширение формы - это дополнительные свойства, методы и параметры формы объекта УправляемаяФорма, характерные для типа основного реквизита формы.

У реквизита объекта или динамического списка есть в форме, есть галочка: "Использовать всегда"{
Для реквизита, подчиненного динамическому списку (колонке динамического списка):
	Свойство включено - реквизит всегда считывается из базы данных и включается в данные формы.
	Свойство выключено - реквизит считывается из базы данных и включается в данные формы только тогда, когда есть видимый в данный момент элемент формы, связанный с реквизитом или его подчиненным реквизитом.
Остальные реквизиты формы:
	Свойство включено - реквизит будет присутствовать в данных формы вне зависимости от того, есть или нет хоть один элемент формы, который связан с реквизитом или его подчиненным реквизитом.
	Свойство выключено - реквизит будет присутствовать в данных формы только в том случае, если есть элемент формы, связанный с реквизитом или его подчиненным реквизитом. В отличие от реквизитов динамического списка, здесь не играет роли видимость элемента, связанного с реквизитом.
}

Обновление формы:{
Изменения данных формы отображаются элементами формы после окончания выполнения встроенного языка или после принудительного вызова метода ОбновитьОтображениеДанных().

Пример:
Допустим, в форме есть реквизит Счетчик типа Число. Этот реквизит отображается на форме полем типа Поле индикатора. Пусть есть некоторое действие, ход выполнения которого должен отображаться индикатором. Действие вызывается нажатием кнопки на форме:
Процедура ОбработчикКомандыФормы()
    Для Счетчик=1 по 100 Цикл
        ВыполнитьДействие();
    КонецЦикла
КонецПроцедуры
Если нажать кнопку, инициирующую эту команду, в режиме 1С:Предприятия, то индикатор вначале будет в крайнем левом положении, а потом ‑ сразу в крайнем правом (считаем, что метод ВыполнитьДействие() выполняется какое-то время, что должно позволить увидеть изменение индикатора). То есть индикатор будет обновлен только после того, как закончится исполнение обработчика команды.
Для того чтобы индикатор отображал ход выполнения процесса, нужно код обработчика заменить нижеследующим:
Процедура ОбработчикКомандыФормы()
    Для Счетчик=1 по 100 Цикл
        ВыполнитьДействие();
        ОбновитьОтображениеДанных();
    КонецЦикла
КонецПроцедуры
}

Способы получения и кеширования данных динамическим списком{
Динамический список использует для получения данных один из трех способов:
	1:- Считывание из базы данных выполняется порциями с количеством элементов данных, несколько превышающим количество строк, одновременно отображаемых списком (но не менее 20). Не выполняется кеширование данных на сервере.
	2:- Считывание из базы данных выполняется страницами по 1 000 элементов данных. Выполняется кеширование данных на сервере. Иерархические данные кешируются: для каждого родителя кешируется не более 2 страниц элементов. На один динамический список кешируется не более 20 страниц элементов.
	3:- Считывание из базы данных выполняется страницами по 1 000 элементов. Первая порция равна 1 странице. Каждая следующая порция увеличивается на 1 страницу (при достижении конца предыдущей выборки). Чем ближе передвигается «точка просмотра» к концу отображаемых данных, тем большая выборка считывается из базы данных, в пределе становясь равной всем отображаемым данным. Выполняется кеширование данных на сервере. Максимальное количество записей в кеше и динамическом списке - 1 000 000.
В зависимости от того, что выбрано основной таблицей динамического списка и какое значение принимает свойство Динамическое считывание, используются те или иные способы считывания данных:
	Свойство Основная таблица не указано, используется произвольный запрос:
		Ключ, идентифицирующий строку таблицы: Число.
		Свойство Динамическое считывание не применимо.
		Используется способ 3.
	В качестве значения свойства Основная таблица указана одна из следующих таблиц: план обмена, справочник, список документов, журнал документов, план видов характеристик, план счетов, план видов расчета, бизнес-процесс, задача, таблица точек бизнес-процесса:
		Ключ, идентифицирующий строку таблицы: Ссылка.
		Свойство Динамическое считывание:
			Установлено: используется способ 1.
			Сброшено: используется способ 2.
При создании формы, содержащей динамический список, первоначально на клиента передается 45 элементов данных каждого видимого динамического списка (если в списке более 45 элементов). Если динамический список отображает более 45 строк, то при открытии формы будет выполнен дополнительный серверный вызов для получения недостающих элементов данных.
Для отображения данные передаются на клиента порциями, размер которых аналогичен размеру порции в 1-м способе считывания данных (описан в начале данного раздела).

СОВЕТ. Следует помнить о том, что неудачный выбор полей сортировки (равно как отбора и группировки данных) негативно влияет на эффективность динамической выборки.
}

ТекущиеДанные и ТекущаяСтрока{
	Табличное поле предоставляет свойства ТекущиеДанные и ТекущаяСтрока. Отличие между этими свойствами состоит в том, что свойство ТекущиеДанные содержит значения считанных данных текущей строки табличного поля, а свойство ТекущаяСтрока содержит значение, идентифицирующее строку.
	Свойство ТекущиеДанные предназначено для получения значений колонок текущей строки, а свойство ТекущаяСтрока для получения и установки текущей строки табличного поля.

Типичной ошибкой является обращение к данным строки с использованием свойства ТекущаяСтрока. В этом случае будет выполняться считывание данных объекта из базы данных, что может существенно снизить производительность работы табличного поля. Например, приведенный ниже фрагмент текста программы является неэффективным:
Процедура СправочникСписокПриАктивизацииСтроки(Элемент)
Сообщить("Цена = " + ЭлементыФормы.СправочникСписок.ТекущаяСтрока.Цена);
КонецПроцедуры 
Рекомендуется для обращения к данным объекта использовать свойство ТекущиеДанные. 
Правильный фрагмент приведен ниже:
Процедура СправочникСписокПриАктивизацииСтроки(Элемент)
Cообщить("Цена = " + ЭлементыФормы.СправочникСписок.ТекущиеДанные.Цена);
КонецПроцедуры
}

Признак модифицированности у формы{
Для сигнализации пользователю о том, что данные, отображаемые формой, были изменены, у формы существует признак модифицированности. При взведении данного признака в заголовке формы отображается символ *. Данный символ сигнализирует пользователю, что данные были изменены, и их необходимо сохранить.
Признак модификации формы взводится системой в следующих случаях:
	1-Изменение объекта, являющимся значением основного реквизита формы. Это изменение может быть произведено интерактивно с помощью элемента управления связанным с реквизитом объекта или программно.
	2-При изменении данных или отработке события элемента управления, у которого взведен флаг "изменяет данные".
Если ты сделаешь команду, которая изменит реквизит объекта документа, то никакого знака не будет- изменений произойдет, теперь у объекта другой реквизит, но ничего, никакого знака или сигнала нет.
А если у этой же команды поставить галочку- изменяет сохраняемые данные, то знак появиться.

Можно програмно установить:
	ЭтаФорма.Модифицированность=Истина;
}

"Cохраняемые данные" для реквизитов формы{
Этот флаг означает, что модификация реквизита изменяет статус модификации объекта-данных формы + ТолькоПросмотр наложенный на форму будет влиять и на этот реквизит.
Если установить:
		ЭтаФорма.ТолькоПросмотр=Истина;
То реквизит станет недоступен. А остальные реквизиты без галочки можно будет изменять.
И если ты изменишь этот реквизит- появиться признак модифицированности формы.

При установке свойства формы ТолькоПросмотр также становятся недоступными кнопки, связанные с предопределенными действиями расширения формы. Обычно эти действия связаны с изменением редактируемых данных или сохранением изменений в информационной базе. Например, для формы документа, при установке свойства формы ТолькоПросмотр, станут недоступны все кнопки связанные с действиями Записать, ЗаписатьИЗакрыть и  Провести.
}

Связь поля с текущими данными таблицы{
Мы можем создать поле, и в выборе ПутьКДанным выбрать Элементы.ТабличнаяЧасть1.ТекущиеДанные.Реквизит2.
И поле будет отображать данные текущего выбранного реквизита.	
}

Синхронизация Списка и Дерева динамического группового списка{
Если есть справочник иерархический, то можно сделать два динамических списка:
	1- иерархический список,
	2- дерево.
В дереве отображаются группы. При выборе группы в списке отображаются элементы этой группы.
У формы есть свойство: "Список групп"
В свойстве Список групп, в этом случае, следует указать таблицу управляемой формы, отображающей динамический список, который отображает только иерархию групп отображаемого справочника.	
С обычным списком такое не прокатывает. Нужно именно динамический список дерева с отбором по группам и иерархический список.
}

Воображаемая линия, которая проходит по границе между заголовками и данными всех элементов, расположенных в группе{
	У группы есть свойство: Выравнивание элементов и заголовков.
От него зависит, будет ли поле ввода прижато к заголову. Можно сделать, чтобы полеввода было полнотью прижато к заголову, а можно чтобы оно было прижато к воображаемой линии. Или чтобы заголовки были прижаты к полю, можно выравнивание вообще убрать. Много вариантов.
Выравнивание границ осуществляется в рамках текущего группирующего элемента.
Если установить в группы свойство: "Сквозное выравнивание" то выравнивание будет путем установки одинаковой ширины для заголовков элементов, которые (заголовки) расположены слева с учетом элементов не входящих в группу.
Высота строки определяется как максимальная высота одного из элементов формы, которые расположены по одной горизонтали, и у которых совпадают верхние границы (если предположить, что свойство Вертикальное положение в группе у всех элементов установлено в одинаковое значение).
Если у группы был сброшен флажок Объединенная группа, группа перестает восприниматься механизмом размещения как единое целое. Каждый элемент группы учитывается отдельно.
}

ОбработкаПолученияФормы{
При попытке открыть любую форму, стандартными средствами, срабатывает событие "ОбработкаПолученияФормы" в модуле менеджера.	
Данный обработчик вызывается только в том случае, если происходит попытка открыть стандартную форму объекта с помощью имен форм по умолчанию.
ОткрытьФорму("Справочник.Номенклатура.ФормаОбъекта");  //так сработает
ОткрытьФорму("Справочник.Товары.Форма.ФормаЭлемента"); //не сработает.
В нем можно указать необходимую форму.
Процедура ОбработкаПолученияФормы(ВидФормы, Параметры, ВыбраннаяФорма, ДополнительнаяИнформация, СтандартнаяОбработка)
    Если ВидФормы = "ФормаОбъекта" И Параметры.Ключ.Вид = Перечисления.ВидыТоваров.Услуга Тогда
        ВыбраннаяФорма = Метаданные.Справочники.Товары.Формы.ФормаУслуги;
        СтандартнаяОбработка = Ложь;
    КонецЕсли;
КонецПроцедуры
Обработчик ОбработкаПолученияФормы не вызывается при попытке открытия общих форм, форм констант, форм хранилищ настроек, внешних отчетов и внешних обработок.
}

Програмная работа с реквизитами{
Изменение (добавление и удаление) реквизитов выполняется методом ИзменитьРеквизиты() объекта УправляемаяФорма. При этом действия удаления и добавления выполняются за один вызов. Это позволяет выполнять операцию изменения свойств реквизитов формы. При этом следует понимать, что операция изменения состава реквизитов является ресурсоемкой операцией (фактически происходит полное создание формы), именно поэтому операции изменения состава реквизитов формы выполняются пакетным образом.

МоиРеквизиты = Новый Массив;
МоиРеквизиты.Добавить(Новый РеквизитФормы("ТаблицаДанных", Новый ОписаниеТипов("ТаблицаЗначений"), , "Таблица значений", Ложь));
МоиРеквизиты.Добавить(Новый РеквизитФормы("Поставщик", Новый ОписаниеТипов("СправочникСсылка.Контрагенты"), "ТаблицаДанных", "Кто поставляет", Ложь));
МоиРеквизиты.Добавить(Новый РеквизитФормы("Товар", Новый ОписаниеТипов("СправочникСсылка.Товары"), "ТаблицаДанных", "Имя товара", Ложь));
После того как были созданы все реквизиты, которые планировалось создать в форме, следует выполнить изменение списка реквизитов
ИзменитьРеквизиты(ДобавляемыеРеквизиты, УдаляемыеРеквизиты);
При удалении реквизитов происходит потеря данных, которые в них содержатся, однако если добавляемый и удаляемый реквизит имеют совместимые типы или добавляемый реквизит отличается от удаляемого реквизита только свойствами (но не типом), то данные, хранимые реквизитом, будут сохранены.
После добавления реквизита обращение к нему в программном коде возможно только с помощью конструкции ЭтотОбъект.ИмяРеквизита. Выражение «ЭтотОбъект.» является обязательным для программно добавляемых реквизитов.
Для того чтобы изменить состав или свойства реквизитов, следует вначале получить изменяемые реквизиты. Сделать это можно с помощью метода ПолучитьРеквизиты().
Следует обратить внимание на две особенности полученного списка:
	● данный список не является динамическим и не отслеживает изменения реквизитов, которые произошли после вызова метода;
	● несмотря на то, что полученный список можно изменять, эти изменения никак не отразятся на реальных свойствах реквизитов формы.
После того как получен интересующий нас список реквизитов формы, можно выполнить с полученными реквизитами какие-либо действия (например, изменить заголовки всех реквизитов) и затем выполнить метод изменения реквизитов.
Изменение реквизитов следует делать с предварительным удалением.
Например, если мы хотим изменить свойства реквизита ПараметрЗаказа, то это следует делать таким образом:
МассивРеквизитов = ПолучитьРеквизиты("ПараметрЗаказа");
...
// Выполним изменения реквизита
...
УдаляемыеРеквизиты = Новый Массив;
УдаляемыеРеквизиты.Добавить("ПараметрЗаказа");
ИзменитьРеквизиты(МассивРеквизитов, УдаляемыеРеквизиты);
}

Изменение состава команд{
Для того чтобы управлять составом команд формы, у объекта УправляемаяФорма существует специальная коллекция ‑ Команды. С помощью этой коллекции мы можем добавлять, удалять и изменять команды формы.
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
    Команда = Команды.Добавить("КомандаУстановкиСтатуса");
    Команда.Действие = "ОбработчикПрограммныхКоманд";
    Команда.Заголовок = "Установить статус";
КонецПроцедуры
&НаКлиенте
Процедура ОбработчикПрограммныхКоманд(Команда)
    ...
КонецПроцедуры	
}

}//EndRegion "description technical"

Макетообразные документы ТабДок,html док,текст док, макет{

Табличный документ и его настройка из формы{
На форме можно создать реквизит ТабличныйДокумент и у него в настройке можно выбрать флажок, тогда в поле появиться лист выбора: Да|Нет, можно установить тип значения ДокументСсылка.<ИмяДокумента> и тогда появиться поле ввода, где можно из всплывающего списка выбрать документ-будет из формы выбора документа выбрать док. А если установить дату, то появиться календарь, который можно открыть и выбрать дату.
}//EndRegion "

HTML документ{
У html документа есть вверху, где правка есть таблица,элементы (в той же линии, где конфигурация, отладка, администрирование), можно выбрать картинку, и вставить картинку,линию, таблицу, и еще пара функций есть. Что-то сгененировать можно.
}//EndRegion "HTML документ"



}//EndRegion

XTDO{
XDTO введение{
XDTO - это механизм, разработанный фирмой “1С” для обмена данными с другими программными системами посредством XML, позволяющий на уровне языка 1С оперировать не узлами XML, а прикладными понятиями “Сотрудник”, “Счет” и привычными встроенными типами (“ТаблицаЗначений”, “СправочникСсылка” и т.п.).

Для того, чтобы корректно прочитать данный документ, мы должны знать структуру того, как в документе расположены данные. Для этого существует такая вещь, как Схема XML. Схема XML представляет собой документ, в котором описаны все типы, которые могут встретиться в документе. Схема однозначно указывает, какие узлы и в каком порядке должны располагаться в документе. Кроме того, она представляет наборы узлов в виде функциональных типов данных, таких, как “Сотрудник”. Что еще более приятно - типы могут наследоваться и составлять иерархии типов.
Если у нас будет набор бизнес-объектов, которые нужно передать по сети в виде XML, то мы можем создать XML-документ. Низкоуровневые вопросы формирования XML и размещения его в документе возьмет на себя платформа.

Как платформа узнает о том, какие свойства есть у сотрудника и как его записывать в XML-файл? Ответ только один - из схемы XML документа. Платформа знает какие свойства могут быть у объекта, потому, что этот объект описан в схеме будущего документа. Закономерный вывод - XDTO без схемы документа работать не может. Система типов обязательно должна быть известна, только тогда мы сможем создавать объекты этих типов, присваивать им свойства, записывать и читать их из XML потока. Платформа позволяет оперировать фрагментами XML-документов, как обыкновенными объектами, к которым можно, например, обращаться “через точку”. При этом, сами объекты описываются в XML-схеме, и именно из нее платформа узнает - как выглядит тот или иной объект. То, как выглядит объект, называется типом. То есть, чтобы получить объект мы должны знать его тип.
}//EndRegion "XDTO введение"

Пространства имен{
Если вдруг две системы имен (созданных разными программистами) встретятся в рамках одной информационной системы, то произойдет конфликт имен.{
Например, Вася создал тип данных “Сотрудник” со свойством “ФИО” и Петя создал объект "Сотрудник" со свойствами “Фамилия”, “Имя”, “Отчество” и “ИНН”. Объекты разные, а имя типа одно, возникает путаница. Чтобы этого избежать, используются пространства имен. Все имена должны быть уникальны в рамках одного пространства имен. Имена в разных пространствах запросто могут повторять друг друга.
}

По традиции (и по многим другим соображениям), пространства именуются в виде URL-подобных строк. Например, “http://vasya.org/xml/sotrudniki”. Причем, это не ссылка в сети, это просто строка-идентификатор. 
Так вот, это не адреса, это уникальные идентификаторы пространств имен. Строка может быть любой.
Теперь, все типы, которые изобретет Вася, он поместит в свое пространство имен и творчество Пети ему не страшно. Всегда можно отличить одного “Сотрудника” от другого.
}//EndRegion "Пространства имен"
Тип данных всегда дополняется пространством имен, в котором этот тип нужно искать.
При построении системы типов XDTO используется понятие Модели данных. Модель представляет собой совокупность всех типов, которые можно записать в один XML документ. С понятием модели неразрывно связано понятие Фабрики XDTO. Фабрика, это объект платформы 1С:Предприятие, который позволяет создавать те самые объекты “Сотрудник”, к которым можно обращаться “через точку”. Именно фабрика создает объект встроенного языка и наделяет его свойствами “ФИО” и “ИНН”, позволяя виртуальной машине обращаться к этим свойствам. Перечень возможных типов и их свойств фабрика берет из модели данных, которая в конечном итоге представляет собой просто набор схем XML.

}//EndRegion "XTDO"

Запросы{
Справка > Содержание справки > 1С:Предприятие > Встроенный язык > Работа с запросами > Синтаксис текста запросов > Использование выражений в языке запросов.

Явное указание типа параметров: ВЫРАЗИТЬ(&Представление КАК Строка(100)){
Если в произвольном тексте запроса динамического списка в выражениях полей выборки используются параметры - следует явно указать тип параметров при помощи конструкции ВЫРАЗИТЬ:
	ВЫРАЗИТЬ(&Представление КАК Строка(100))	- явное приведение значения параметра к нужному типу.
Например, вместо &Номенклатура КАК Номеклатура использовать ВЫРАЗИТЬ(&Номенклатура КАК Справочник.Номенклатура) КАК Номенклатура.
Выразить не может приводить один тип к другому. Из числа строку не сделать.
	ВЫРАЗИТЬ(РасходнаяНакладная.Номер как Дата),//не работает
	ВЫРАЗИТЬ(РасходнаяНакладная.Номер как СТРОКА),//работает, но номер и так строка
	ВЫРАЗИТЬ(РасходнаяНакладная.Ссылка как СТРОКА), //не работает
Постоянно будем получать ошибку: Несовместимые типы "Выразить".
Ни вложенный запрос, ни вт не могут приводить один тип к другому.
}

Обращение в запросах к предопределенным данным конфигурации и значениям системных перечислений{
	ЗНАЧЕНИЕ(<ПредставлениеЗначения>)
Для системных перечислений представление значения имеет вид:
	<ИмяСистемногоПеречисления>.<Значение>
Для предопределенных данных конфигурации представление значения имеет вид:
	<ТипПредопределенногоЗначения>.<ИмяОбъектаМетаданных>.<Значение>
Для точек маршрутов бизнес-процессов представление значения имеет вид:
	БизнесПроцесс.<ИмяОбъектаМетаданных>.ТочкаМаршрута.<ИмяТочкиМаршрута>
Тип предопределенного значения может быть:
	● Справочник (Catalog);
	● ПланВидовХарактеристик (ChartOfCharacteristicTypes);
	● ПланСчетов (ChartOfAccounts);
	● ПланВидовРасчета (ChartOfCalculationTypes);
	● Перечисление (Enum).
Примеры:
	Документ1.Реквизит1 = ЗНАЧЕНИЕ(Перечисление.Перечисление1.Алегрия)
	ГДЕ Город = ЗНАЧЕНИЕ(Справочник.Города.Москва)
	ГДЕ Город = ЗНАЧЕНИЕ(Справочник.Города.ПустаяСсылка)
	ГДЕ ТипТовара = ЗНАЧЕНИЕ(Перечисление.ВидыТоваров.Услуга)
	ГДЕ ВидДвижения = ЗНАЧЕНИЕ(ВидДвиженияНакопления.Приход)
	ГДЕ ТочкаМаршрута = ЗНАЧЕНИЕ(БизнесПроцесс.Согласование.ТочкаМаршрута.Согласие)
}

Вложенная таблица{
Есть документ, у которого есть реквизит1 и табличная часть с двумя реквизитами.
Можно сделать выборку, которая выберет табчасть, ссылку и реквизит1 - у выборки будет три поля, одно из которых таблица.
"Выбрать
		| Документ.Документ1.Ссылка,
		| Документ.Документ1.Реквизит1,
		| Документ.Документ1.ТабличнаяЧасть1.(Реквизит1 Как Товар,Реквизит2)";	
}

ВЫБРАТЬ [РАЗРЕШЕННЫЕ] [РАЗЛИЧНЫЕ] [ПЕРВЫЕ <Количество>]
    <Список полей выборки>
[ИЗ <Список источников>]
[ГДЕ <Условие отбора>]
[СГРУППИРОВАТЬ ПО <Поля группировки>]
[ИМЕЮЩИЕ <Условие отбора>]
[ДЛЯ ИЗМЕНЕНИЯ [<Список таблиц верхнего уровня>]]

Ключевое слово РАЗРЕШЕННЫЕ означает, что запрос выберет только те записи, на которые у текущего пользователя есть права. Если данное слово не указать, то запрос отработает с ошибкой, когда он выберет записи, на которые у пользователя нет прав. 

С помощью ключевого слова РАЗЛИЧНЫЕ можно указать, что в результат не должны попадать повторяющиеся строки.
 
Типы соединений: ПОЛНОЕ ВНЕШНЕЕ СОЕДИНЕНИЕ | ВНУТРЕННЕЕ | ЛЕВОЕ [ВНЕШНЕЕ] СОЕДИНЕНИЕ | ПРАВОЕ [ВНЕШНЕЕ] СОЕДИНЕНИЕ {
Ключевое слова ВНУТРЕННЕЕ можно не указывать вообще, оно повышает наглядность и удобочитаемость текста запроса.
Ключевое слова ВНЕШНЕЕ можно не указывать вообще, оно повышает наглядность и удобочитаемость текста запроса.


Внутреннее соединение означает, что из обеих исходных таблиц - источников данных в результат запроса необходимо включить только те комбинации записей, которые соответствуют указанному условию. Остальные записи в результат не попадают.

Левое внешнее соединение означает, что в результат запроса нужно включить комбинации записей из обеих исходных таблиц, которые соответствуют указанному условию. Но, в отличие от внутреннего соединения, в результат запроса нужно включить также еще и записи из первого (указанного слева от слова СОЕДИНЕНИЕ) источника, для которых не найдено соответствующих условию записей из второго источника.

Правое внешнее соединение означает, что в результат запроса нужно включить комбинации записей из обеих исходных таблиц, которые соответствуют указанному условию. Кроме того, в результат запроса нужно также включить и записи из второго (указанного справа от слова СОЕДИНЕНИЕ) источника, для которых не найдено соответствующих условию записей из первого источника.

Полное внешнее соединение означает, что в результат запроса нужно включить комбинации записей из обеих исходных таблиц, которые соответствуют указанному условию. Кроме того, в результат запроса нужно также включить и те записи из обоих источников, для которых не найдено соответствий.

Следует обратить внимание, что при указании вложенной таблицы в списке источников допускается обращение как к полям самой вложенной таблицы, так и к полям таблицы верхнего уровня (той, которая содержит вложенную таблицу) через поле Ссылка. В данном случае происходит обращение к полю Ссылка.НаименованиеПоля самого документа.
}

Предложение ИМЕЮЩИЕ <Условие отбора> позволяет накладывать условия на значения агрегатных функций. В других конструкциях языка запросов, например, в предложении ГДЕ, указывать в условиях агрегатные функции нельзя.{
// Необходимо выбрать товары, которых продали более 20 штук.
ВЫБРАТЬ
    Накладная.Номенклатура,
    СУММА(Накладная.Количество) КАК Количество
ИЗ
    Документ.РасходнаяНакладная.Состав КАК Накладная
СГРУППИРОВАТЬ ПО
    Накладная.Номенклатура
ИМЕЮЩИЕ
    СУММА(Накладная.Количество) > 20		
}

В языке запросов имеется возможность объединять несколько запросов. При объединении каждый запрос собирает данные независимо, а такие операции, как упорядочивание результатов и расчет итогов, выполняются уже над результатом объединения запросов.

Функции языка запросов{
	СУММА - Функция вычисляет арифметическую сумму всех попавших в выборку значений поля. В качестве параметра функции можно указывать только поля, содержащие числовое значение.
	СРЕДНЕЕ - Функция вычисляет среднее значение всех попавших в выборку значений поля. В качестве параметра функции можно указывать только ссылки на поля, содержащие числовое значение.
	МИНИМУМ - Функция вычисляет минимальное значение из всех попавших в выборку значений поля. В качестве параметра функции можно указывать ссылки на поля, содержащие значения любого типа. При определении минимального значения применяются правила сравнения значений, описанные в разделе «Правила сравнения значений».
	МАКСИМУМ - Функция вычисляет максимальное значение из всех попавших в выборку значений поля. В качестве параметра функции можно указывать выражения, содержащие значения любого типа. Не может применяться к выражениям с типом ХранилищеЗначения, МоментВремени и строкам неограниченной длины.
	КОЛИЧЕСТВО - Функция подсчитывает количество значений параметра, попавших в выборку. В отличие от других агрегатных функций, функция КОЛИЧЕСТВО допускает три способа использования:
		● Функция позволяет подсчитать количество значений указанного поля, не равных NULL.
		● Функция позволяет подсчитать количество различных значений указанного поля, не равных NULL. Для этого перед спецификацией поля нужно указать ключевое слово РАЗЛИЧНЫЕ.
		● Функция позволяет подсчитать количество строк в результате запроса. Для этого в качестве параметра функции нужно указать звездочку «*».
	В качестве параметра функции можно указывать ссылки на поля, содержащие значения любого типа.
	ПОДСТРОКА ( <Выражение>, <Значение>, <Значение> ) - Данная функция предназначена для выделения подстроки из строки. В функцию передаются три параметра:
		● Строка, из которой необходимо выделить подстроку. Выражение, имеющее тип Строка.
		● Позиция символа, с которого начинается выделяемая из строки подстрока. Значение типа Число.
		● Длина выделяемой подстроки. Значение типа Число.
	Если в качестве первого параметра фигурирует строка, то результатом функции будет строка (возможно, нулевой длины). Если в качестве первого параметра будет использовано значение NULL, то результатом функции также будет значение NULL. Другие значения считаются недопустимыми и вызывают состояние ошибки.
	ПОДСТРОКА(Контрагенты.Наименование, 3, 5) КАК Подстрока
	ГОД - Данная функция предназначена для вычисления номера года из значения типа Дата. Параметр функции - это выражение, имеющее тип Дата. Если в качестве параметра фигурирует значение типа Дата, то результатом функции будет значение типа Число.
	КВАРТАЛ - Данная функция предназначена для вычисления номера квартала из значения типа Дата. Номер квартала находится в диапазоне 1–4. Параметр функции - это выражение, имеющее тип Дата.
	МЕСЯЦ - Номер месяца находится в диапазоне 1–12.
	ДЕНЬГОДА -  День года находится в диапазоне 1–366.
	ДЕНЬ - День месяца находится в диапазоне 1–31.
	НЕДЕЛЯ - Данная функция предназначена для вычисления номера недели года из значения типа Дата.
	ДЕНЬНЕДЕЛИ - . День недели находится в диапазоне 1 (понедельник) - 7 (воскресенье).
	ЧАС - Час суток находится в диапазоне 0–23.
	МИНУТА - Минута часа находится в диапазоне 0–59.
	СЕКУНДА - Секунда минуты находится в диапазоне 0–59.
	НАЧАЛОПЕРИОДА(<Выражение>, Минута | Час | День | Неделя | Месяц | Квартал | Год | Декада | Полугодие)  - Параметры функции - это выражение, имеющее тип Дата и тип периода - одно из значений: Минута, Час, День, Неделя, Месяц, Квартал, Год, Декада, Полугодие. Если тип периода указан Неделя, то учитывается значение свойства Первый день недели региональных установок информационной базы. 
		ВЫБРАТЬ НАЧАЛОПЕРИОДА(ДАТАВРЕМЯ (2002, 10, 12, 10, 15, 34), МЕСЯЦ) получим 01.10.2002.
		ВЫБРАТЬ НАЧАЛОПЕРИОДА(ДАТАВРЕМЯ(2002, 10, 12, 10, 15, 34), ДЕНЬ) получим 12.10.2002
	КОНЕЦПЕРИОДА - Функция предназначена для выделения определенной даты из заданной даты.
		ВЫБРАТЬ КОНЕЦПЕРИОДА(ДАТАВРЕМЯ(2002, 10, 12, 10, 15, 34), МЕСЯЦ) получим 31.10.2002 23:59:59.
	ДОБАВИТЬКДАТЕ (<Выражение>, Минута | Час | День | Неделя | Месяц | Квартал | Год | Декада | Полугодие, <Выражение>) - Функция предназначена для прибавления к дате некоторой величины:
		Первый параметр - исходная дата, к значению которой требуется добавить заданную величину, определяемую вторым и третьим параметрами; выражение, имеющее тип Дата.
		Второй параметр - тип увеличения, одно из значений: Секунда, Минута, Час, День, Неделя, Месяц, Квартал, Год, Декада, Полугодие. Следует учитывать, что под термином Декада понимается строго 10 дней, вне зависимости от даты, указанной в первом параметре функции.
		Третий параметр - величина, на которую требуется увеличить дату, задаваемую первым параметром; тип Число (дробная часть игнорируется).
	Рекомендуется третий параметр (размерность увеличения) указывать так, чтобы он соответствовал решаемой прикладной задаче. Так, если прикладная задача оперирует днями или месяцами, то следует добавлять к дате именно дни и месяцы. Использование больших чисел в качестве значений второго и третьего параметров может приводить к следующим проблемам:
	● Различное выполнение перехода на зимнее/летнее время на разных СУБД.
	● Выход за границу диапазона дат, поддерживаемых СУБД.
	● Выход за пределы допустимых значений параметра.
	ВЫБРАТЬ    ДОБАВИТЬКДАТЕ(ДАТАВРЕМЯ(2002, 10, 12, 10, 15, 34), МЕСЯЦ, 1) получим 12.11.2002 10:15:34.
	ВЫБРАТЬ ДобавитьКДате(ДатаВремя(2002, 10, 12, 10, 15, 34), День, 5) получим 17.10.2002 10:15:34.
	РАЗНОСТЬДАТ(<Выражение>, <Выражение>, Секунда | Минута | Час | День | Месяц | Квартал | Год) - Функция предназначена для получения разницы между двумя датами. Первый параметр - выражение типа Дата. Второй параметр - выражение типа Дата. Третий параметр - тип разности, одно из значений: Секунда, Минута, Час, День, Месяц, Квартал, Год. Не поддерживается использование данной функции при задании значения параметра виртуальной таблицы Период.
	ВЫБРАТЬ РАЗНОСТЬДАТ(ДАТАВРЕМЯ(2002, 10, 12, 10, 15, 34), ДАТАВРЕМЯ(2002, 10, 14, 9, 18, 06), ДЕНЬ) получим 2.
	ВЫБРАТЬ РАЗНОСТЬДАТ(ДатаВремя(2002, 10, 12), ДатаВремя(2002, 11, 03), МЕСЯЦ) получим 1.
	Функция рассчитывает календарную разницу между двумя датами, поэтому ее нельзя использовать там, где необходимо рассчитать количество банковских или рабочих дней между двумя датами.
	ТИПЗНАЧЕНИЯ(<Выражение>) - Функция определения типа значения в запросе. Параметр функции -  выражение любого типа. Возвращаемое значение - значение типа Тип. Если параметром функции является значение Неопределено, то возвращаемое значение также будет Неопределено.
	 ТИПЗНАЧЕНИЯ(УчетНоменклатуры.Регистратор) КАК Документ
	ПРЕДСТАВЛЕНИЕ(<Выражение>)- Данная функция предназначена для получения строкового представления значения произвольного типа. Параметр функции - выражение любого типа. Возвращаемое значение - представление значения, тип Строка. Результат работы функции не может быть использован внутри других функций, за исключением функции ПРЕДСТАВЛЕНИЕ.
	ПРЕДСТАВЛЕНИЕ(Документ.Контрагент) КАК Получатель,
	ПРЕДСТАВЛЕНИЕ(Документ.Дата) КАК Дата.
	ЕСТЬNULL(<Выражение>, <Выражение>) - Функция предназначена для замены значения NULL на другое значение.Параметры функции:
		● первый параметр - выражение любого типа;
		● второй параметр - выражение любого типа.
	Возвращаемое значение: значение первого параметра, если первый параметр не содержит значение NULL; значение второго параметра в противном случае.
	ЕСТЬNULL(СУММА(РасходнаяНакладнаяСостав.Количество), 0)
	
	ВЫРАЗИТЬ ( <Выражение> КАК <Тип значения> )
	<Тип значения> может быть:
	Булево |
	Число [(Длина[, Точность])]|
	Строка [(Длина)]|
	Дата |
	<Имя таблицы>
	Выражение приводится к одному из примитивных типов или к ссылочному типу данных. В последнем случае имя таблицы указывает на соответствующую таблицу информационной базы. Если выражение содержит в составном типе требуемый тип значения, то приведение типа считается осуществимым, и для каждого значения указанного типа результатом будет это самое значение. Для значений других типов результатом приведения типа будет значение NULL.
	
	ТИП(<Имя типа>) - <Имя типа> - имя примитивного типа либо имя таблицы, тип ссылки которой нужно получить. Результатом данной конструкции будет значение типа Тип для указанного типа.
	// Получение типа "Строка"
	ТИП(Строка)
	// Получение типа - ссылка на справочник "Номенклатура"
	ТИП(Справочник.Номенклатура)
	ВЫБРАТЬ
		ТИПЗНАЧЕНИЯ(Остатки.Регистратор)
	ИЗ
		РегистрНакопления.УчетНоменклатуры КАК Остатки
	ГДЕ
	ТИПЗНАЧЕНИЯ(Остатки.Регистратор) = ТИП(Документ.РасходнаяНакладная)	
}

Условия в запросах{
В операции выбора может указываться неограниченное количество альтернативных одиночных выборов КОГДА … ТОГДА. Они обрабатываются в запросе последовательно. Если логическое выражение имеет значение Истина, обработка операции выбора завершается. Результатом операции является значение выражения, указанного после слова ТОГДА. Значение выражения, указанного после слова ИНАЧЕ, используется в качестве результата операции выбора в том случае, если во всех ранее указанных альтернативных одиночных выборах предикат имел значение Ложь.
	ВЫБРАТЬ
    Номенклатура.Наименование,
    ВЫБОР
        КОГДА Номенклатура.ЭтоГруппа = ИСТИНА
            ТОГДА "Это группа"
        КОГДА Номенклатура.ЗакупочнаяЦена > 1000
            ТОГДА "1000 -"
        КОГДА Номенклатура.ЗакупочнаяЦена > 100
            ТОГДА "100 - 1000"
        КОГДА Номенклатура.ЗакупочнаяЦена > 10
            ТОГДА "10 - 100"
        КОГДА Номенклатура.ЗакупочнаяЦена > 0
            ТОГДА "0 - 10"
        ИНАЧЕ "Не задана"
    КОНЕЦ КАК Цена
ИЗ
    Справочник.Номенклатура КАК Номенклатура
	
Условия могут определяться и как более сложные логические выражения, где фигурируют простые логические выражения, соединенные между собой с помощью логических операторов И, ИЛИ, НЕ.
Логические операторы имеют приоритет:
	● Самый высокий приоритет имеет логический оператор НЕ.
	● Следующим по приоритету является оператор И.
	● Самый низкий приоритет у оператора ИЛИ.
	● В условиях сначала вычисляются простые логические выражения, затем операции НЕ, затем операции И, в последнюю очередь - операции ИЛИ. Для того чтобы обеспечить другой порядок вычислений, можно использовать круглые скобки ().

Форма оператора «В» для проверки совпадения с одним из перечисленных.	
Оператор В позволяет проверить, совпадает ли значение выражения, указанного справа от него, с одним из значений, описанных слева. Если совпадает хотя бы с одним, результатом оператора будет Истина, иначе - Ложь. Применение НЕ изменяет действие оператора на обратное.
ГДЕ
    Номенклатура.Родитель.Наименование В
        ("Бытовая техника", "Оргтехника")
Форма оператора «В» для проверки принадлежности по иерархии
	ГДЕ
		Номенклатура.Ссылка В ИЕРАРХИИ(&Группа)
Или в иерархии через запрос:
ВЫБРАТЬ
    Номенклатура.Наименование
ИЗ
    Справочник.Номенклатура КАК Номенклатура
ГДЕ
    Номенклатура.Ссылка В ИЕРАРХИИ
        (ВЫБРАТЬ
            Номенклатура.Ссылка
        ИЗ
            Справочник.Номенклатура КАК Номенклатура
        ГДЕ
            Номенклатура.Наименование = "Одежда")
// Выбрать названия товаров, которые присутствовали
// в расходных накладных
ВЫБРАТЬ
    Товары.Наименование
ИЗ
    Справочник.Номенклатура КАК Товары
ГДЕ
    Товары.Ссылка В
        (ВЫБРАТЬ
            РасходнаяНакладнаяСостав.Номенклатура
        ИЗ
            Документ.РасходнаяНакладная.Состав КАК РасходнаяНакладнаяСостав)

Оператор МЕЖДУ позволяет проверить, входит ли значение выражения, указанного слева от него, в диапазон, указанный справа. Если входит, результатом оператора будет Истина, иначе - Ложь. Применение НЕ изменяет действие оператора на обратное. 
ГДЕ
    Номенклатура.ЗакупочнаяЦена МЕЖДУ 100 И 1000

Оператор ЕСТЬNULL позволяет проверить значение выражения слева от него на NULL. Если значение равно NULL, результатом оператора будет Истина, иначе - Ложь. Применение НЕ изменяет действие оператора на обратное.
ГДЕ
    Номенклатура.ЗакупочнаяЦена ЕСТЬ NULL

Оператор ССЫЛКА позволяет проверить, является ли значение выражения, указанного слева от него, ссылкой на таблицу, указанную справа. Если да, результатом оператора будет Истина, иначе - Ложь. 
ГДЕ
    РасходнаяНакладная.Контрагент ССЫЛКА Справочник.Контрагенты

Оператор ПОДОБНО позволяет сравнить значение выражения, указанного слева от него, со строкой шаблона, указанной справа. Значение выражения должно иметь тип Строка. Если значение выражения удовлетворяет шаблону, результатом оператора будет Истина, иначе - Ложь.
Следующие символы в строке шаблона являются служебными и имеют смысл, отличный от символа строки:
	● «%» (процент): последовательность, содержащая любое количество произвольных символов.
	● «_» (подчеркивание): один произвольный символ.
	● «[…]» (в квадратных скобках один или несколько символов): любой одиночный символ из перечисленных внутри квадратных скобок. В перечислении могут встречаться диапазоны, например, a-z, означающие произвольный символ, входящий в диапазон, включая концы диапазона.
	● «[^…]» (в квадратных скобках значок отрицания, за которым следует один или несколько символов): любой одиночный символ, кроме тех, которые перечислены следом за значком отрицания.
Любой другой символ означает сам себя и не несет никакой дополнительной нагрузки.
}

Временные таблицы{
МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
Все временные таблицы, созданные в данном экземпляре менеджера, существуют до тех пор, пока существует сам экземпляр менеджера временных таблиц. При уничтожении экземпляра менеджера все временные таблицы, которые содержатся в нем, также удаляются.
Менеджер временных таблиц можно закрыть принудительно при помощи метода Закрыть(). При этом будут удалены все созданные в нем таблицы. Дальнейшая работа с данным экземпляром менеджера будет невозможна.

Создание временных таблиц осуществляется с помощью объекта Запрос встроенного языка системы «1С:Предприятие».
Связь запроса с менеджером временных таблиц осуществляется с помощью свойства МенеджерВременныхТаблиц запроса, в котором указывается тот экземпляр менеджера, в котором должны создаваться временные таблицы.

	МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;

Для того чтобы создать временную таблицу на основе данных базы данных, следует установить объекту Запрос менеджер временных таблиц, а затем выполнить запрос к базе данных, используя ключевое слово ПОМЕСТИТЬ, после которого указать имя создаваемой временной таблицы. 
Ключевое слово ПОМЕСТИТЬ располагается после списка выборки запроса.
ВЫБРАТЬ
    Номенклатура.Код,
    Номенклатура.Наименование
ПОМЕСТИТЬ ВременнаяТаблица
ИЗ
    Справочник.Номенклатура КАК Номенклатура
Результат исполнения такого запроса будет содержать одну строку с одной колонкой Количество, в которой будут находиться записи, помещенные в созданную таблицу.
Для того чтобы создать временную таблицу и заблокировать данные таблиц, на основании которых создается временная таблица, следует использовать конструкцию ДЛЯ ИЗМЕНЕНИЯ.
ВЫБРАТЬ
    РасходнаяНакладная.Ссылка,
    РасходнаяНакладная.Номер,
    РасходнаяНакладная.Дата
ПОМЕСТИТЬ ВременнаяТаблица
ИЗ
    Документ.РасходнаяНакладная КАК РасходнаяНакладная
ГДЕ
    РасходнаяНакладная.Ссылка В(&Документы)
ДЛЯ ИЗМЕНЕНИЯ

Для использования существующих временных таблиц в запросе следует установить объекту Запрос менеджер временных таблиц, после чего к временным таблицам, содержащимся в данном менеджере временных таблиц, можно обращаться по имени, как к обычным таблицам запроса.

При желании можно задезть в МенеджерВременныхТаблиц и из него вытащить таблицу, чтобы посмотреть на нее:
ПродажиТЗ = Запрос.МенеджерВременныхТаблиц.Таблицы["Продажи"].ПолучитьДанные().Выгрузить();
ОстаткиТЗ = Запрос.МенеджерВременныхТаблиц.Таблицы[1].ПолучитьДанные().Выгрузить();
В результате выполнения запроса свойство Запрос.МенеджерВременныхТаблиц.Таблицы станет содержать коллекцию временных таблиц, содержащих результаты исполнения пакетного запроса. С помощью свойства Таблицы можно получать доступ к каждой временной таблице, причем делать это можно как по имени, так и по индексу временной таблицы. 
}

Пакетные запросы{
В пакетном запросе тексты запросов разделяются символом «;». Запросы исполняются последовательно, при этом временные таблицы, которые были созданы во время исполнения какого-либо запроса, будут существовать до окончания исполнения всего пакета запроса или до исполнения в пакете запроса, уничтожающего данную временную таблицу, например:
Запрос = Новый Запрос;
Запрос.Текст =
    "ВЫБРАТЬ
    |УчетНоменклатурыОстаткиИОбороты.Номенклатура,
    |УчетНоменклатурыОстаткиИОбороты.КоличествоПриход,
    |УчетНоменклатурыОстаткиИОбороты.КоличествоРасход,
    |УчетНоменклатурыОстаткиИОбороты.КоличествоКонечныйОстаток
    |ПОМЕСТИТЬ УчетНоменклатуры
    |ИЗ
    |РегистрНакопления.УчетНоменклатуры.ОстаткиИОбороты(, , Авто, , ) КАК УчетНоменклатурыОстаткиИОбороты
    |;
    |
    |ВЫБРАТЬ
    |УчетНоменклатуры.Номенклатура,
    |УчетНоменклатуры.КоличествоРасход,
    |УчетНоменклатуры.КоличествоКонечныйОстаток
    |ИЗ
    |УчетНоменклатуры КАК УчетНоменклатуры
    |";
Результат = Запрос.Выполнить();
Первый запрос создает временную таблицу, данные из которой используются во втором запросе.

Если объекту Запрос, исполняющему пакетный запрос, установлен менеджер временных таблиц, временные таблицы, которые не были уничтожены в рамках пакетного запроса, сохранятся в установленном менеджере.

Кроме метода Выполнить(), последовательно выполняющего все запросы пакета и возвращающего результат последнего запроса в пакете, платформа системы «1С:Предприятие» предоставляет еще один метод ‑ ВыполнитьПакет(). Этот метод последовательно выполняет все запросы и возвращает массив результатов для каждого запроса из пакета в последовательности расположения запросов в тексте пакета. Результатом выполнения запроса на уничтожение временной таблицы является значение Неопределено, которое также помещается в массив результатов.

При необходимости отладки пакетного запроса, предоставляется возможность использовать метод ВыполнитьПакетСПромежуточнымиДанными(). В этом случае результат работы аналогичен методу ВыполнитьПакет() с тем отличием, что временные таблицы, сформированные в пакете запросов, будут представлены не количеством записей в соответствующей временной таблице (как при вызове метода ВыполнитьПакет()), а содержимым этой временной таблицы.

Запрос = Новый Запрос;
Запрос.Текст =
    "ВЫБРАТЬ
    |УчетНоменклатурыОстаткиИОбороты.Номенклатура,
    |УчетНоменклатурыОстаткиИОбороты.КоличествоПриход,
    |УчетНоменклатурыОстаткиИОбороты.КоличествоРасход,
    |УчетНоменклатурыОстаткиИОбороты.КоличествоКонечныйОстаток
    |ПОМЕСТИТЬ УчетНоменклатуры
    |ИЗ
    |РегистрНакопления.УчетНоменклатуры.ОстаткиИОбороты(, , Авто, , ) КАК УчетНоменклатурыОстаткиИОбороты
    |;
    |
    |ВЫБРАТЬ
    |УчетНоменклатуры.Номенклатура,
    |УчетНоменклатуры.КоличествоРасход,
    |УчетНоменклатуры.КоличествоКонечныйОстаток
    |ИЗ
    |УчетНоменклатуры КАК УчетНоменклатуры
    |";
РезультатПакета = Запрос.ВыполнитьПакетСПромежуточнымиДанными();
ВременнаяТаблица = РезультатПакета[0].Выгрузить();
Результат = РезультатПакета[1].Выгрузить();
В этом случае в переменной ВременнаяТаблица будет доступна таблица значений, которая содержит данные временной таблицы УчетНоменклатуры, а в переменной Результат будет доступна временная таблица с результатом работы последнего запроса пакета (фактический результат работы пакета).
}

Hurt программный генератор запросов{
Для программного формирования или изменения запроса есть объект: СхемаЗапроса.
С помощью свойства ПакетЗапросов разработчик получает доступ ко всем запросам, которые в данный момент редактируются с помощью объекта СхемаЗапроса. Методы УстановитьТекстЗапроса() предназначен для заполнения объекта СхемаЗапроса на основании переданного текста запроса, а метод ПолучитьТекстЗапроса() служит для обратной операции.
Такой запрос:
ВЫБРАТЬ
    ТоварныеЗапасыОстатки.Товар КАК Товар,
    ТоварныеЗапасыОстатки.Склад КАК Склад,
    ТоварныеЗапасыОстатки.КоличествоОстаток КАК КоличествоОстаток,
    ВЫБОР
        КОГДА ТоварныеЗапасыОстатки.КоличествоОстаток > 0
            ТОГДА "Достаточно"
        ИНАЧЕ "Недостаточно"
    КОНЕЦ КАК Состояние
ИЗ
    РегистрНакопления.ТоварныеЗапасы.Остатки КАК ТоварныеЗапасыОстатки
ГДЕ
    ТоварныеЗапасыОстатки.Склад = &Склад
УПОРЯДОЧИТЬ ПО
    Товар,
    Склад,
    КоличествоОстаток
ИТОГИ
    СУММА(КоличествоОстаток)
ПО
    ОБЩИЕ,
    Товар,
    Склад

Равен коду на встроенном языке:

Конструктор = Новый СхемаЗапроса;
Пакет1 = Конструктор.ПакетЗапросов[0];
Оператор1 = Пакет1.Операторы[0];
// добавим источник в запрос
ТаблицаРегистра = Оператор1.Источники.Добавить("РегистрНакопления.ТоварныеЗапасы.Остатки", "ТоварныеЗапасыОстатки");
// добавим поля в запрос
ПолеТовар = Оператор1.ВыбираемыеПоля.Добавить("ТоварныеЗапасыОстатки.Товар", 0);
ДоступноеПолеСклад = ТаблицаРегистра.Источник.ДоступныеПоля.Найти("Склад");
ПолеСклад = Оператор1.ВыбираемыеПоля.Добавить(ДоступноеПолеСклад, 1);
ПолеКоличество = Оператор1.ВыбираемыеПоля.Добавить("КоличествоОстаток", 2);
ВыражениеВыбора = Новый ВыражениеСхемыЗапроса("ВЫБОР
                |    КОГДА ТоварныеЗапасыОстатки.КоличествоОстаток > 0
                |        ТОГДА ""Достаточно""
                |    ИНАЧЕ ""Недостаточно""
                |КОНЕЦ");
ПолеВыбора = Оператор1.ВыбираемыеПоля.Добавить(Строка(ВыражениеВыбора), 3);
// зададим псевдонимы
Результат = Пакет1.Колонки.Найти(ПолеКоличество);
Результат.Псевдоним = "КоличествоОстаток";
Результат = Пакет1.Колонки[1];
Результат.Псевдоним = "Склад";
Результат = Пакет1.Колонки.Найти(ВыражениеВыбора);
Результат.Псевдоним = "Состояние";
// добавим условие
Оператор1.Отбор.Добавить(Строка(ПолеСклад) + " = &Склад");
// добавим упорядочивание
Пакет1.Порядок.Добавить(ПолеТовар);
Пакет1.Порядок.Добавить("Склад");
Пакет1.Порядок.Добавить("КоличествоОстаток");
// зададим контрольные точки итогов
Пакет1.ОбщиеИтоги = Истина;
Пакет1.КонтрольныеТочкиИтогов.Добавить(ПолеТовар);
Пакет1.КонтрольныеТочкиИтогов.Добавить("Склад");
// зададим агрегатные функции для итогов
КолонкаКоличество = Пакет1.Колонки.Найти(ПолеКоличество);
Пакет1.ВыраженияИтогов.Добавить("Сумма(" + КолонкаКоличество.Псевдоним +")");
Текст = Конструктор.ПолучитьТекстЗапроса();
}

ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0) - пустая дата.
Запрос без таблиц нужен для высчитывания разности дат{
Выбрать 
РАЗНОСТЬДАТ(&д1, &д2, День) как ВДнях,
РАЗНОСТЬДАТ(&д1, &д2, Месяц) как ВМесяцах
В месяце может быть 30 или 31 день. И объектной моделью, не запросом тяжело найти, аналогичной функции в 1С нет.
}

Итоги - это виртуальный механизм работающий после выполнения запроса. Запрос уже выполнен и это постобработка запроса.
"ГДЕ" выполняется до группировки, а "ИМЕЮЩИЕ" после группировки.{
	ИМЕЮЩИЕ СУММА(Количество)>10
функция с "ИМЕЮЩИЕ" может не совпадать с группировкой.
}

Параметры виртуальных таблиц{
Виртуальные таблицы, как функции:
	РегистрСведений.ИмяРегистра.СрезПоследних(&Аргумент1,&Аргумент2)
И они работают как функции-они вернут данные в соотвествии с аргументами. И запрос продолжится.
Если поставить условия в &Аргумент2 то сначало применятся эти условия, а потом продолжится запрос с его условие "ГДЕ".
Отборы лучше все пихать в параметры, так запрос будет быстрее выполняться.
}

Null<>Null. Нельзя Null сравнивать с Null.
"Есть Null" использовать такое для проверки на Null.
ЕстьNull(<Условие>,0)//Или такое.
Проверка на ЕстьNull одна из самых медленных операций системы. Допустим выбираем себестоимость и количество из регистра. На Null проверяем только количество. Себестоимость же будет зависит от того, есть количество или нет. Просто так ЕстьNull лучше не пихать везде.

ПОЛНОЕ СОЕДИНЕНИЕ это когда у обоих таблиц стоят галочки.
Если одно-то это или правое или левое.
Если галочек нет-это ВНУТРЕННЕЕ СОЕДИНЕНИЕ- когда данные есть и в одной и в другой таблице.
}

Блокировки{
«1С:Предприятие» обеспечивает два вида объектных блокировок ‑ пессимистическую и оптимистическую. Они позволяют выполнять целостные изменения объектов при одновременной работе нескольких пользователей.

Пессимистическая блокировка{
В основном механизм пессимистической блокировки используется системой «1С:Предприятие» для блокировки объектов, редактируемых в форме. В то же время разработчик имеет возможность задействовать этот механизм, используя средства встроенного языка. В тот момент, когда пользователь начинает модификацию объекта в форме, расширение формы устанавливает пессимистическую блокировку. Если после этого другой пользователь, например, попытается выполнить редактирование того же объекта, ему будет выдано сообщение о том, что не удалось заблокировать объект. Когда пользователь, редактировавший объект, закроет форму объекта, расширение формы снимет пессимистическую блокировку.
	
В том случае, если необходимо в нестандартной форме объекта обеспечить такое же поведение, что и в стандартной форме объекта, можно использовать метод формы ЗаблокироватьДанныеФормыДляРедактирования() для установки пессимистической блокировки и метод формы РазблокироватьДанныеФормыДляРедактирования() для снятия блокировки.
Однако следует учитывать, что сам по себе факт установки блокировки не препятствует изменению или удалению объекта в базе данных. Поэтому для того, чтобы обеспечить невозможность изменения заблокированного объекта, операции изменения объекта в другом сеансе также должна предшествовать попытка блокировки этого объекта. 
Блокировка заблокированного объекта базы данных вызывает исключение, которое может быть обработано конструкцией Попытка … Исключение … КонецПопытки.
Операции блокировки объектов влияют только на выполнение других операций блокировки объектов и не влияют на операции над данными и на процесс течения транзакций.
}
	
Оптимистическая блокировка{
Оптимистическая блокировка запрещает запись объекта в базу данных, если после считывания объекта он был изменен в базе данных.
Строго говоря, оптимистическая блокировка представляет собой проверку, которая выполняется перед записью объекта в базу данных. Когда объект встроенного языка считывает данные из базы данных, в числе прочего считывается и версия объекта, хранящегося в базе данных. Если до начала редактирования данных пользователем (до установки пессимистической блокировки) данные объекта в базе данных были изменены (например, другим пользователем), то номер версии объекта, хранящийся в базе данных, также изменится. При попытке пользователя записать этот объект будет выполнена проверка соответствия версии объекта, находящегося в памяти, и версии объекта, хранящейся в базе данных. Так как версии отличаются, будет выдано предупреждение о том, что версия объекта изменилась или он был удален, то есть сработает оптимистическая блокировка.

Оптимистическая блокировка гарантирует, что если пользователь изменяет объект, то его изменения не «затрут» изменения, сделанные другими сеансами или другими программными объектами этого же сеанса.
}

Транзакции{
Транзакция - это неделимая с точки зрения воздействия на базу данных последовательность операций манипулирования данными. Она выполняется по принципу «все или ничего» и переводит базу данных из одного целостного состояния в другое целостное состояние. Если по каким-либо причинам одно из действий транзакции невыполнимо или произошло какое-либо нарушение работы системы, база данных возвращается в то состояние, которое было до начала транзакции (происходит откат транзакции).
Система «1С:Предприятие» осуществляет неявный вызов транзакций при выполнении любых действий, связанных с модификацией информации, хранящейся в базе данных. 
Наряду с этим разработчик может использовать работу с транзакциями в явном виде. Для этого используются процедуры глобального контекста НачатьТранзакцию(), ЗафиксироватьТранзакцию() и ОтменитьТранзакцию().

Метод НачатьТранзакцию() позволяет открыть транзакцию. После этого все изменения информации базы данных, выполняемые последующими операторами, могут быть либо целиком приняты, либо целиком отвергнуты.

Для принятия всех выполненных изменений используется метод ЗафиксироватьТранзакцию(). Для того чтобы отменить все изменения, выполнявшиеся в открытой транзакции, используется метод ОтменитьТранзакцию(). Если количество вызовов метода НачатьТранзакцию() превышает количество вызовов методов ЗафиксироватьТранзакцию() или ОтменитьТранзакцию(), то система выполнит неявный вызов метода ОтменитьТранзакцию() в следующих случаях:
	● при окончании выполнения встроенного языка (обработчик события, внешнее соединение, automation-сервер);
	● при передаче управления с сервера на клиента.
Если количество вызовов методов ЗафиксироватьТранзакцию() или ОтменитьТранзакцию() превышает количество вызовов метода НачатьТранзакцию(), то при выполнении лишнего вызова метода ЗафиксироватьТранзакцию() или ОтменитьТранзакцию() будет порождено исключение.
Попытка
    НачатьТранзакцию();
    // Последовательность операторов
    …
    ЗафиксироватьТранзакцию();
Исключение
    ОтменитьТранзакцию();
КонецПопытки;

В рамках уже выполняемой транзакции можно обращаться к процедурам НачатьТранзакцию(), ЗафиксироватьТранзакцию() и ОтменитьТранзакцию(). Например, может использоваться следующая схема вызовов:
НачатьТранзакцию();
    // Вложенный вызов транзакции
    НачатьТранзакцию();
    ЗафиксироватьТранзакцию();
    // Вложенный вызов транзакции
    НачатьТранзакцию();
    ЗафиксироватьТранзакцию();
ЗафиксироватьТранзакцию();
Однако подобное обращение не означает начала новой транзакции в рамках уже выполняющейся.
ВНИМАНИЕ! Система «1С:Предприятие» не поддерживает вложенных транзакций.
Это означает, что всегда действует только транзакция самого верхнего уровня. Все транзакции, вызванные внутри уже открытой транзакции, фактически относятся к той же транзакции, а не образуют вложенную транзакцию. Таким образом, отмена изменений, выполняемая во вложенной транзакции, будет приводить в конечном счете не к отмене изменений самой вложенной транзакции, а к отмене всех изменений транзакции верхнего уровня. В то же время фиксация изменений, выполненная во вложенной транзакции, игнорируется.
}

Блокировки теория{
В идеальном случае в любой СУБД несколько транзакций, выполняющих изменение данных, не должны мешать друг другу.
Самым простым способом решения этой проблемы является последовательное выполнение транзакций. Следующая транзакция выполняется после того, как закончилась предыдущая. Однако в реальной ситуации, при многопользовательской работе, такой подход приводит к резкому снижению производительности системы. Поэтому на практике используются механизмы, позволяющие выполнять несколько транзакций одновременно.
Для того чтобы одновременное выполнение транзакций стало возможным, используется несколько уровней изоляции транзакций. На самом низком уровне изоляции транзакции могут сильно влиять друг на друга. На самом высоком уровне они полностью изолированы.
С точки зрения системы «1С:Предприятие» работа с данными может выполняться в одном из двух режимов:
	● в транзакции,
	● вне транзакции.
Режим работы с данными вне транзакции допускает только операции чтения данных. Этот режим введен для того, чтобы обеспечить максимальную скорость и параллельность чтения данных. Поэтому любая операция чтения данных, выполняемая вне транзакции, считается безответственной. Это означает, что такая операция чтения может вернуть устаревшие данные или даже незафиксированные изменения, произведенные другой транзакцией, т. е. чтение выполняется «не глядя» на блокировки данных, расставленные другими транзакциями.
Система «1С:Предприятие» позволяет использовать два режима работы с базой данных в рамках транзакции: режим автоматических блокировок и режим управляемых блокировок.

Режим автоматических блокировок не требует от разработчика каких-либо действий по управлению блокировками в транзакции для того, чтобы обеспечивались перечисленные выше правила работы с данными в транзакции. Эти правила обеспечиваются платформой системы «1С:Предприятие» за счет использования определенных уровней изоляции транзакций в той или иной СУБД. Такой режим работы является наиболее простым для разработчика, однако в некоторых случаях (например, при интенсивной одновременной работе большого количества пользователей) используемый уровень изоляции транзакций в СУБД не может обеспечить достаточной параллельности работы, что проявляется в виде большого количества конфликтов блокировок при работе пользователей.

При работе в режиме управляемых блокировок система «1С:Предприятие» использует гораздо более низкий уровень изоляции транзакций в СУБД, что позволяет значительно повысить параллельность работы пользователей прикладного решения. Однако, в отличие от режима автоматических блокировок, данный уровень изоляции транзакций уже не может сам по себе обеспечить выполнение всех правил работы с данными в транзакции (в частности, не обеспечивается воспроизводимость чтения данных в транзакции). Поэтому при работе в управляемом режиме от разработчика требуется самостоятельно управлять блокировками, устанавливаемыми в транзакции.

Конфигурация имеет свойство Режим управления блокировкой данных. Каждый прикладной объект конфигурации также имеет свойство Режим управления блокировкой данных.
ежим управления блокировкой данных для всей конфигурации в целом может быть установлен в значения Автоматический, Управляемый (установлено по умолчанию для новой конфигурации) и Автоматический и управляемый. Значения Автоматический и Управляемый означают, что соответствующий режим блокировки будет использоваться для всех объектов конфигурации, независимо от значений, установленных для каждого из объектов. Значение Автоматический и управляемый означает, что для конкретного объекта конфигурации будет использован тот режим, который указан в его свойстве Режим управления блокировкой данных: Автоматический или Управляемый.

Если же, например, операция записи объекта выполняется в транзакции, инициированной разработчиком (метод НачатьТранзакцию()), то режим управления блокировкой данных будет определяться значением параметра РежимБлокировок метода НачатьТранзакцию(), а не значением свойства объекта метаданных Режим управления блокировкой данных.
По умолчанию параметр РежимБлокировок имеет значение РежимУправленияБлокировкойДанных.Автоматический, поэтому для того, чтобы в явной транзакции использовать режим управляемых блокировок, следует указывать значение этого параметра РежимУправленияБлокировкойДанных.Управляемый.
}

Объект БлокировкаДанных{
 Экземпляр этого объекта может быть создан с помощью конструктора и позволяет описать необходимые пространства блокировок и режимы блокировок. Для установки всех созданных блокировок используется метод Заблокировать() объекта БлокировкаДанных.

Запрещено устанавливать блокировки по реквизитам (и общим реквизитам) следующих типов: строка неограниченной длины, хранилище значения, тип значения плана видов характеристик, составной тип, включающий один из вышеперечисленных типов. Запрет относится к следующим объектам: справочники, документы, планы видов характеристик, планы видов расчета, планы счетов, бизнес-процессы, задачи, планы обмена. Также запрещено устанавливать блокировки по полям Предопределенный и ИмяПредопределенныхДанных в справочниках, планах видов характеристик, планах видов расчета, планах счетов.
Для каждого пространства блокировки может быть задано произвольное количество условий на поля, по которым будут определяться записи, подлежащие блокировке. 
При явном указании значения поля в параметры метода УстановитьЗначение() передается имя поля и значение:
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("Справочник.Магазин");
	ЭлементБлокировки.УстановитьЗначение("Код", 100);
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
	Блокировка.Заблокировать();
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить("РегистрНакопления.ТоварыНаСкладах");
	ЭлементБлокировки.УстановитьЗначение("Качество", Справочники.Качество.НайтиПоКоду("1"));
Следует иметь в виду, что одну и ту же запись регистра можно заблокировать дважды: первый раз блокируя саму запись, а второй раз - блокируя набор, в который эта запись входит.

При использовании источника данных устанавливается значение свойства ИсточникДанных, а затем с помощью метода ИспользоватьИзИсточникаДанных() задается соответствие полей области блокировки полям источника данных:
Блокировка = Новый БлокировкаДанных;
ЭлементБлокировки = Блокировка. Добавить("РегистрНакопления.ТоварыНаСкладах");
ЭлементБлокировки.ИсточникДанных = ДокументОбъект.ВозвратнаяТара;
ЭлементБлокировки.ИспользоватьИзИсточникаДанных("Номенклатура", "Номенклатура");
ЭлементБлокировки.ИспользоватьИзИсточникаДанных("Склад", "Склад");

Для каждого элемента блокировки может быть задан один из двух режимов блокировки:
	● разделяемый,
	● исключительный.

Разделяемый режим блокировки подразумевает, что заблокированные данные не могут быть изменены другой транзакцией до окончания текущей транзакции.
Исключительный режим блокировки подразумевает, что заблокированные данные не могут быть изменены другой транзакцией до окончания текущей транзакции, а также не могут быть прочитаны другой транзакцией, устанавливающей разделяемую блокировку на эти данные.
● Исключительный режим блокировки следует устанавливать для тех данных, которые должны быть изменены в рамках этой же транзакции. Это позволит предотвратить конфликты блокировок.
● Разделяемый режим блокировки следует устанавливать для тех данных, которые только считываются и изменять которые не предполагается, но заблокировать от изменений все-таки требуется.

}

}

Система компоновки данных{

Теория несколько наборов данных{
Система компоновки данных позволяет использовать в одной компоновке несколько наборов данных. Для того чтобы в одной компоновке использовать несколько наборов данных, необходимо внести в схему описания наборов данных, которые предполагается использовать, и указать связи между наборами данных.
Если в системе компоновки данных описывается связь между двумя наборами данных, то набор данных, к которому идет связь, будет считаться зависимым. Набор данных, от которого идет связь, будет считаться родительским по отношению к зависимому от него набору данных. В схеме компоновки данных нет указания типа связи. Все связи считаются левыми внешними соединениями. То есть запись родительского набора данных будет использоваться в компоновке даже в том случае, если для нее не найдены записи в зависимом наборе.

В макете компоновки данных возможно указание типа связи. Тип связи генерируется компоновщиком макета в зависимости от накладываемых глобальных отборов. Если на поле набора данных, являющегося зависимым, накладывается глобальный отбор, генерируемые связи в макете компоновки данных от этого набора данных до всех его родительских наборов (вплоть до начала иерархии наборов данных) будут иметь тип Внутренняя. Это означает, что записи родительского набора данных будут участвовать в компоновке только в том случае, если будут найдены записи в зависимых наборах данных.

Если и зависимый, и родительский набор данных содержит поле с одинаковым именем, данное поле будет получаться из родительского набора данных.
Несвязанные наборы данных не могут содержать поля с одинаковыми именами, если у них нет общего родителя, в котором данное поле также присутствует.
}

Расширение языка запросов для системы компоновки данных{
	Заключаем инструкцию в фигурные скобки и вставляет в запрос.
Смысл не понял. Не вижу особой необходимости и слабо понимаю, зачем это надо.
В общем есть несколько дополнительных синтаксических конструкций:
{ВЫБРАТЬ Номенклатура, Склад}
{ГДЕ Номенклатура.*, Склад }
{ГДЕ Документ.Дата >= &ДатаНачала, Документ.Дата <= &ДатаКонца}
ВЫБРАТЬ
    УчетНоменклатурыОбороты.Номенклатура КАК Номенклатура,
    УчетНоменклатурыОбороты.Склад КАК Склад,
    УчетНоменклатурыОбороты.КоличествоПриход КАК КоличествоПриход,
    УчетНоменклатурыОбороты.КоличествоРасход КАК КоличествоРасход
ИЗ
    РегистрНакопления.УчетНоменклатуры.Обороты({&ДатаНачала},
            {&ДатаКонца},
            ,
            {Номенклатура.*, Склад.*}) КАК УчетНоменклатурыОбороты
То есть есть возможность в запрос какую-то конструкцию запихнуть и тогда пользователь сможет выбирать для вывода эти поля, которые в ней указаны или определить так поля, на которые пользователь сможет накладывать отбор. 	
}

Язык выражений системы компоновки данных{
Язык выражений нужен для:
	● схема компоновки данных ‑ для описания вычисляемых полей, полей итогов, выражений связи и т. д.;
	● настройки компоновки данных ‑ для описания выражений пользовательских полей;
	● макет компоновки данных ‑ для описания выражений связи наборов данных, описания параметров макета и т. д.
Примечание. В языке выражений компоновки данных отсутствует возможность получения поля через точку от выражения.
Строковый литерал записывается в символах «"». При необходимости использования внутри строкового литерала символа «"» следует использовать два таких символа.
	"Литерал ""в кавычках"""
Число записывается без пробелов, в десятичном формате. Дробная часть отделяется при помощи символа «.».
	10.5
	200
Литерал типа Дата записывается при помощи ключевого слова ДАТАВРЕМЯ (DATETIME). После данного ключевого слова в скобках, через запятую, перечисляются год, месяц, день, часы, минуты, секунды. Указание времени необязательно.
	// Шестое января 1975 года
	ДАТАВРЕМЯ(1975, 1, 06)
	// Второе декабря 2006 года, 23 часа 56 минут 57 секунд
	ДАТАВРЕМЯ(2006, 12, 2, 23, 56, 57)
Булевы значения могут быть записаны при помощи литералов Истина (True), Ложь (False).
Для указания литералов других типов (системных перечислений, предопределенных данных) используется ключевое слово ЗНАЧЕНИЕ, после которого в скобках идет указание имени литерала.
	ЗНАЧЕНИЕ(ВидСчета.Активный)
В выражениях могут использоваться поля наборов данных. Поле идентифицируется путем к данным. Части пути к данным отделяются друг от друга символом «.». Имя поля не является чувствительным к регистру. Если путь к данным содержит идентификатор с пробелами или специальными символами, то такие идентификаторы следует заключать в квадратные скобки.
	Номенклатура.Артикул
	Продажи.СуммаОборот
	Продажи.[Сумма оборот]
Выражения могут использовать параметры. Для использования в выражении параметра достаточно написать его имя, которому будет предшествовать символ «&».
	&Контрагент
	&ДатаНачала
Формирует значение типа Тип. Тип задается при помощи ключевого слова Тип.	
	Тип("Строка")
Унарный "-" - для изменения знака числа на обратный.
	-Продажи.Количество
Бинарный "-" для вычисления разности двух чисел.
	ОстИОбрт.НачальныйОстаток - ОстИОбрт.КонечныйОстаток
	ОстИОбрт.НачальныйОстаток - 100
	400 - 357
Бинарный "+" для вычисления суммы двух чисел.
	ОстИОбрт.НачальныйОстаток + ОстИОбрт.Оборот
	ОстИОбрт.НачальныйОстаток + 100
	400 + 357
Произведение "*"  для вычисления произведения двух чисел.
	Номенклатура.Цена * 1.2
	2 * 3.14
Деление "/" для получения результата деления одного операнда на другой.
	Номенклатура.Цена / 1.2
	2 / 3.14
статок от деления "%"  для получения остатка от деления одного операнда на другой.
	Номенклатура.Цена % 1.2
	2 % 3.14
Конкатенация (Бинарный "+")  для конкатенации двух строк.
	Номенклатура.Артикул + ": "+ Номенклатура.Наименование
ПОДОБНО (LIKE) проверяет соответствие строки переданному шаблону.
Значением оператора ПОДОБНО является Истина, если значение выражения удовлетворяет шаблону, и Ложь - в противном случае.

Строка начинается с подстроки (НачинаетсяС/BeginsWith) - осуществляет проверку того, что проверяемое значение начинается на строку, указанную в условии. Условие может быть указано непосредственным значением и шаблоном.

Строка не начинается с подстроки (НеНачинаетсяС/NotBeginsWith) - осуществляет проверку того, что проверяемое значение не начинается на строку, указанную в условии. Условие может быть указано непосредственным значением и шаблоном.

Строка не удовлетворяет шаблону (НеПодобно/NotLike)

Операция проверки вхождения в список (В/IN)  осуществляет проверку наличия значения в переданном списке значений. Результатом операции будет Истина, если значение найдено, или Ложь - в противном случае.
	Номенклатура В (&Товар1, &Товар2)
Операция проверки наличия значения в наборе данных (В/IN)
	Продажи.Контрагент В Контрагенты
Операция проверки значения на NULL (ЕСТЬ NULL/IS NULL) - возвращает значение Истина, если оно является значением NULL.
	Продажи.Контрагент ЕСТЬ NULL
Операция проверки значения на неравенство NULL (ЕСТЬ НЕ NULL/IS NOT NULL) - возвращает значение Истина, если оно не является значением NULL.
	Продажи.Контрагент ЕСТЬ НЕ NULL
Операция НЕ (NOT) -возвращает значение Истина, если ее операнд имеет значение Ложь, и значение Ложь, если ее операнд имеет значение Истина.
	НЕ Документ.Грузополучатель = Документ.Грузоотправитель
Операция И (AND) - возвращает значение Истина, если оба операнда имеют значение Истина, и значение Ложь, если один из операндов имеет значение Ложь.
	Документ.Грузополучатель = Документ.Грузоотправитель И Документ.Грузополучатель = &Контрагент
Операция ИЛИ (OR)
	Документ.Грузополучатель = Документ.Грузоотправитель ИЛИ Документ.Грузополучатель = &Контрагент
Сумма(Выражение)
	СУММА(Продажи.СуммаОборот)
Количество(Выражение) - рассчитывает количество значений, отличных от значения NULL. В качестве параметра можно передавать Массив. В этом случае функция будет применена к содержимому массива.
	КОЛИЧЕСТВО(Продажи.Контрагент)
КОЛИЧЕСТВО (РАЗЛИЧНЫЕ) (COUNT (DISTINCT)) - Количество(Различные Выражение) рассчитывает количество различных значений. Для получения различных значений следует перед параметром метода Количество указать Различные (Distinct). В качестве параметра можно передавать Массив. В этом случае функция будет применена к содержимому массива.
	КОЛИЧЕСТВО(Различные Продажи.Контрагент)
Максимум(Выражение)
Минимум(Выражение)
Среднее(Выражение)
Массив([Различные] Выражение) - Функция формирует массив, содержащий значение выражения для каждой детальной записи. Если указано ключевое слово Различные, то получаемый массив не будет содержать дублирующихся значений.
	ФункцииОтчетов.СтандартноеОтклонение(Массив(Сумма))
ТаблицаЗначений([Различные] Выражение1 [КАК ИмяКолонки1][, Выражение2 [КАК ИмяКолонки2]], …) -формирует таблицу значений, содержащую столько колонок, сколько параметров у функции.
	ФункцииОтчетов.ТаблицуЗначенийВСтроку(ТаблицаЗначений(Склад КАК Склад, КоличествоОстаток КАК Остаток))
Свернуть(<Выражение>, <НомераКолонок>) - предназначена для удаления дубликатов из массива.
	Свернуть(ТаблицаЗначений(НомерТелефона, Адрес) ,"НомерТелефона");
ПолучитьЧасть(<Выражение>, <НомерКолонок>) - получает таблицу значений, которая содержит указанные колонки исходной таблицы значений.
	ПолучитьЧасть(Свернуть(ТаблицаЗначений(НомерТелефона, Адрес) ,"НомерТелефона"),"НомерТелефона");
Упорядочить(<Выражение>, <НомераКолонок>)
	Упорядочить(ТаблицаЗначений(НомерТелефона, Адрес, ДатаЗвонка),"ДатаЗвонка Убыв");
СоединитьСтроки(<Значения>, <РазделительЭлементов>, <РазделительКолонок>) - для объединения строк в одну строку.
ГрупповаяОбработка(<Выражения>, <ВыраженияИерархии>, <ИмяГруппировки>) - Формируется таблица значений, содержащая значения параметров (в колонках) для каждой групповой записи (в строках).
Каждый(<X>) - определяет наличие в переданном наборе хотя бы одного значения Ложь.
Любой(<X>) - определяет наличие в переданном наборе хотя бы одного значения Истина.
СтандартноеОтклонениеГенеральнойСовокупности(<X>)
СтандартноеОтклонениеВыборки(<X>)
ДисперсияВыборки(<X>)	
ДисперсияГенеральнойСовокупности(<X>)
КовариацияГенеральнойСовокупности(<Y>, <X>)
КовариацияВыборки(<Y>, <X>)
Корреляция(<Y>, <X>)
РегрссияНаклон(<Y>, <X>)	
РегрессияОтрезок(<Y>, <X>)
РегрессияКоличество(<Y>, <X>)
Регрессия_R2(<Y>, <X>)
РегрессияСреднееX(<Y>, <X>)
РегрессияСреднееY(<Y>, <X>)
РегрессияSXX(<Y>, <X>)
РегрессияSYY(<Y>, <X>)
РегрессияSXY(<Y>, <X>)
МестоВПорядке(<Порядок>, <ПорядокИерархии>, <ИмяГруппировки>) - вычисляет, какое место имеет текущая запись среди записей текущей группировки, если ее упорядочить в порядке, указанном в параметрах функции. Нумерация начинается с 1.
КлассификацияABC(<Значение>, <КоличествоГрупп>, <ПроцентыДляГрупп>, <ИмяГруппировки>)

ВЫБОР Когда Сумма > 1000 Тогда Сумма Иначе 0 Конец

ВычислитьВыражение(<Выражение>, <Группировка>, <ОбластьВычисления>, <Начало>, <Конец>, <Сортировка>, <ИерархическаяСортировка>, <ОбработкаОдинаковыхЗначенийПорядка>) -  для вычисления выражения в контексте некоторой группировки.
	Сумма(Продажи.СуммаОборот)/Вычислить("Сумма(Продажи.СуммаОборот)", "ОбщийИтог")
ВычислитьВыражениеСГруппировкойМассив(<Выражение>, <ВыражениеПолейГруппировки>, <ОтборЗаписей>, <ОтборГруппировок>) - возвращает массив, каждый элемент которого содержит результат вычисления выражения для группировки по указанному полю.
ВычислитьВыражениеСГруппировкойТаблицаЗначений(<Выражения>, <ВыражениеПолейГруппировки>, <ОтборЗаписей>, <ОтборГруппировок>)
	ВычислитьВыражениеСГруппировкойТаблицаЗначений ("Контрагент КАК Контрагент, Сумма(СуммаОборот) Как ОбъемПродаж", "Контрагент")

УРОВЕНЬ() -  получения текущего уровня записи.
УРОВЕНЬВГРУППИРОВКЕ() - получения уровня записи относительно корня группировки.
ЗНАЧЕНИЕЗАПОЛНЕНО
НОМЕРПОПОРЯДКУ() - Получить следующий порядковый номер.
НОМЕРПОПОРЯДКУВГРУППИРОВКЕ() - Возвращает следующий порядковый номер в текущей группировке.
ФОРМАТ (FORMAT) -Получить отформатированную строку переданного значения
	ФОРМАТ(РасходныеНакладные.СуммаДок, "ЧДЦ=2")
НАЧАЛОПЕРИОДА(ДатаВремя(2002, 10, 12, 10, 15, 34), "Месяц")
	Минута, Час, День, Неделя, Месяц, Квартал, Год, Декада, Полугодие.
КОНЕЦПЕРИОДА (ENDOFPERIOD) -Минута, Час, День, Неделя, Месяц, Квартал, Год, Декада, Полугодие.
	КОНЕЦПЕРИОДА(ДатаВремя(2002, 10, 12, 10, 15, 34), "Неделя")
ДОБАВИТЬКДАТЕ (DATEADD)
РАЗНОСТЬДАТ (DATEDIFF)
ТЕКУЩАЯДАТА (CURRENTDATE) 
	ТЕКУЩАЯДАТА()
ПОДСТРОКА(Контрагенты.Адрес, 1, 4)
ДЛИНАСТРОКИ(Контрагенты.Адрес)
ГОД(РасхНакл.Дата)
КВАРТАЛ(РасхНакл.Дата)
МЕСЯЦ(РасхНакл.Дата)
ДЕНЬГОДА(РасхНакл.Дата)
ДЕНЬ(РасхНакл.Дата)
НЕДЕЛЯ(РасхНакл.Дата)
ДЕНЬНЕДЕЛИ(РасхНакл.Дата)
ЧАС(РасхНакл.Дата)
МИНУТА(РасхНакл.Дата)
СЕКУНДА(РасхНакл.Дата)
ВЫРАЗИТЬ(Данные.Реквизит1, "Число(10,3)") - для составного типа.
ЕСТЬNULL(Сумма(Продажи.СуммаОборот), 0)
Представление(<Выражение>)
Строка(<Выражение>) - Если в качестве параметра передан массив, то функция возвращает строку, содержащую строковые представления всех элементов массива, разделенных символами "; ". Если в качестве параметра передана таблица значений, то функция возвращает строку, содержащую строковые представления всех строк таблицы значений, причем представления ячеек каждой строки разделяются символами "; ", а строки ‑ символом перевода строки. Если у какого-либо элемента строковое представление пустое, то вместо его представления выводится строка <Пустое значение>.
ACos(<X>)
ASin(<X>)
ATan(<X>)
Cos(<X>)
Sin(<X>)
Tan(<X>)
Exp(<X>)
Log(<X>)
Log10(<X>)
Pow(<X>, <Y>) 
Sqrt(<X>)
Окр(<Выражение>, <КоличествоЗнаков>) -Округляет значение Выражение до КоличествоЗнаков после запятой.
Цел(<Выражение>) -полностью отсекает дробную часть.
ТипЗначения(<Выражение>) возвращает Значение типа Тип.

Выражение механизма компоновки данных может содержать вызовы функций глобальных общих модулей конфигурации и неглобальных общих модулей с установленным свойством Клиент (обычное приложение) (при использовании обычного приложения) или Сервер (при использовании управляемого приложения). Никакого дополнительного синтаксиса для вызова таких функций не требуется.
	В данном примере будет осуществлен вызов функции СокращенноеНаименование() из общего модуля конфигурации:
	СокращенноеНаименование(Докум.Ссылка, Докум.Дата, Докум.Номер)
Использование функций общих модулей разрешено только при указании соответствующего параметра процессора компоновки данных.
Функции общих модулей не могут быть использованы в выражениях пользовательских полей.
}

Набор данных- то где запрос пишем и редактируем поля, самая первая вкладка{
При редактировании полей существует возможность задать:
	● заголовок поля;
	● ограничение доступности поля;
	● ограничение доступности полей-реквизитов;
	● роль для поля;
	● представление поля;
	● выражения упорядочивания;
	● способ проверки иерархии (набор данных и параметр);
	● тип значения поля;
	● оформление поля.	

Есть строка, где в такой очередности указаны:
	иконка реквизита
	Поле
	Путь 
	Заголовок
	Ограничение поля | недоступно для выбора | условия | группировки | упорядочивания
	Ограничение реквизитов | недоступно для выбора | условия | группировки | упорядочивания
	Роль
	Выражение по которому вычисляется представление поля
	Выражение упорядочивания
	Проверка иерархии: Набор данных
	Проверка иерархии:	Параметр
	Тип значения
	Доступные значения
	Оформление
	Параметры редактирования
	
	
Путь – строка, содержащая путь к данным, под которым поле будет фигурировать в настройках и выражениях{
	Путь - то как этот реквизит дальше будет называться в настройке компоновки - как он в ресурсах будет называться или в вычисляемых полях, в доступных полях для выбора- считай это его синоним для внутренней програмной работы.
}

Заголовок – заголовок поля - строка, отображаемая в пользовательских настройках и в заголовке результата компоновки для данного поля; {
	Заголовок- если чуть ниже поставить галочку, то можно выбрать заголовок. Это то, как этот реквизит будет называться в отчете- считай представление для пользователя. Так он будет в пользовательском отборе называться и в пользовательском отчете. Если данный флажок снят, в колонке Заголовок отображается заголовок, который будет выводиться пользователю -автоматически генерируемый заголовок.
}

Ограничение доступности поля – указывается, как данное поле не может быть использовано в настройках. {
	Дальше идут условия ограничение ПОЛЯ, если например поставить галочку, что поле недоступно для выбора, то его не будет в списке доступных полей- не получиться включить его в отчет. А если недоступно для условия поставить галочку - нельзя отбор по этому полю сделать- такого поля просто не будет в списке доступных полей для отбора.

Ограничение доступности полей-реквизитов – указывается, каким образом можно использовать реквизиты (поля "через точку") в пользовательских настройках.{
	А ограничение РЕКВИЗИТА применяется к реквизитам ссылкам, которые на что-то указывают. Так например пользователь в полях видит перед полем ссылка +, что позволяет ему обратиться к полю этого объекта по ссылке. Ссылка + там откроется список и он например реквизит1 по ссылке может получить. А если поставить галочку, то этого плюсика не может, пользователь не сможет открыть это поле и обратиться через него на данные объекта. Есть реквизит3 типа ссылка на документ1, если не ставить галочку, то у пользователя можно зайти в "Изменить вариант" -> Отбор -> реквизит3.Номер содержит ... . А поставить галочку, то там просто будет реквизит3, через него уже обратиться ни к номеру, ни к дате, ни к другим реквизитам нельзя. Только он сам.
}

}

Роль - роль поля – указывает, каким образом следует интерпретировать поле - не понял, что это значит, теорию попробовал почитать, покликал, изменения не заметил. Странная настройка. Не пойму как её можно использовать в обычном отчете.{
	Измерение – признак того, что поле является измерением. Информация о том, что поле является измерением используется при расчете итогов по полям остатка;
	Период – число, содержащее номер периода в случае, если поле является полем – периодом. 
	Игнорировать значения NULL – если установлено, то в результат не нужно включать групповые записи по данному полю в случае, если поле содержит значение NULL.
}

Выражение, по которому вычисляется представление поля - то, как можно изменить значение этого поля в отчете. Допустим в детальных записях есть * из табличной части. У стандартного реквизита НомерСтроки переопределим представление: "Ссылка.Номер+путь" и тогда в каждой строке НомерСтроки будет равен номеру документа, к которому сложили строчно значение реквизита путь из этой же строки табличной части. А если там написать именно ""Вася"" то в везде в таблице в детальных записях в каждой строке колонки НомерСтроки будет именно "Вася" написано. Или например: есть поле ссылка, обычная ссылка документа, в детальных записях оно выведено. И в представление ставим: " КонецПериода(Ссылка.Дата, "День") " и теперь в каждой строки колонки "Ссылка" будет стоять дата этого документа на конец дня: "03.07.2018 23:59:59" в таком духе ( документ от "03.07.2018 10:56:40") , при этом если кликнуть по этой колонке, то откроеться этот документ. Свои свойства - значение ячейка не теряет, просто представление идет такое.

Выражения упорядочивания – описание выражений, по которым следует упорядочивать в случае, если требуется упорядочивать по данному полю - если сделать отбор{
Есть поле строка, если по нему упорядочить, то будет:
	1
	1
	11
	111
	2
	2
	333
	4
	4
	444
	999
А чтобы сделать упорядочивание как по числу:
	Вычислить(Реквизит2) возр    //Выбираем там по возрастанию и пишем где выражение Вычислить(Реквизит2)
И получаем:
	1
	1
	2
	2
	4
	4
	11
	111
	333
	444
	999
}

Проверка иерархии - не знаю что это.

Тип значения - по идее так можно менять значение. Но ТипЗначения(Реквизит2) все равно возвращает строку. Не знаю что это.
}

Смена типа в выражениях системы компоновки данных{
	ВычислитьВыражение(Реквизит2) + НомерСтроки
Так мы из поля строка получили число.
А наоборот по идее можно сделать через:
Строка() или Формат().
	
}

Если для ресурса было указано, что его можно рассчитывать только в разрезе некоторой группировки (то есть в колонке Рассчитывать по… было выбрано хотя бы одно поле группировки), то данный ресурс будет выводиться в результат только для этой группировки и группировок, вложенных в нее.

Вложенные поля(подполе при выборе){
При выборе поля, чтобы поместить его в колонку или строку таблицы, у поля система может сделать вложенные поля.
Если поле числовое ресурс:
	ПроцентВИерархии - Данное поле содержит процент значения ресурса в текущей иерархической группе. При выводе вне таблицы равно 100 %.
	
	ПроцентВИерархииВКолонкеИлиТочке - Данное поле содержит отношение значения ресурса в текущей ячейке к значению итога ресурса на текущем уровне иерархии текущей группировки по колонке или точке (в процентах). При выводе вне таблицы равно полю % в группе иерархии.
	
	ПроцентВИерархииВСтрокеИлиСерии - Данное поле содержит отношение значения ресурса в текущей ячейке к значению итога ресурса на текущем уровне иерархии текущей группировки по строке или серии (в процентах). При выводе вне таблицы равно 100 %.
	
	ПроцентВГруппе- Данное поле содержит отношение значения ресурса в текущей ячейке к значению итога ресурса в текущей группировке. При выводе вне таблицы содержит 100 %.
	
	ПроцентВГруппеВКолонкеИлиТочке - Данное поле содержит отношение значения ресурса в текущей ячейке к значению итога ресурса в текущей группировке по колонке или точке (в процентах). При выводе вне таблицы содержит 100 %.
	
	ПроцентВГруппеВСтрокеИлиСерии - Данное поле содержит отношение значения ресурса в текущей ячейке к значению итога ресурса в текущей группировке по строке или серии (в процентах). При выводе вне таблицы содержит поле % в группировке.
	
	ПроцентВКолонкеИлиТочке - Данное поле содержит отношение значения ресурса в текущей ячейке к значению итога ресурса по колонке или точке (в процентах). При выводе вне таблицы содержит поле % общий.
	
	ПроцентОбщий - Данное поле содержит отношение значения ресурса в текущей ячейке к значению общего итога ресурса в таблице (в процентах). При выводе вне таблицы содержит 100%.
	
У даты есть три группы:
	 Даты начала (ДатыНачала, BeginDates)
		...НачалоКвартала...
	 Даты конца (ДатыКонца, EndDates)
		...КонецПолугодия...
	 Части дат (ЧастиДат, DateParts)
		...ДеньНедели...
}

}

Бухгалтерский учет{
Основное: Планы счетов и Регистры бухгалтерии.
Немного теории{
Планом счетов называется совокупность синтетических счетов, предназначенных для группировки информации о хозяйственной деятельности предприятия. Информация, накапливаемая на таких синтетических счетах, позволяет получить полную картину состояния средств предприятия в денежном выражении.	

Понятие «субконто». Субконто в системе «1С:Предприятие» называется объект аналитического учета. Термином «субконто» могут быть обозначены любые объекты аналитического учета: основные средства, нематериальные активы, материалы, организации, подотчетные лица, договоры, бюджеты. Видом субконто, в свою очередь, называется множество однотипных объектов аналитического учета.
	Например, учет задолженности предприятия перед покупателями и заказчиками обязательно ведется согласно нормативным документам, отдельно по каждому покупателю и заказчику. В системе «1С:Предприятие» такой список покупателей и заказчиков (предположим, что это только организации) будет называться «видом субконто «Организации»», а любая организация из этого списка будет именоваться «субконто».
В качестве универсальных средств описаний свойств объектов аналитического учета используются объекты типа План видов характеристик.
	ВНИМАНИЕ! Для плана видов характеристик, используемого в качестве видов субконто плана счетов, не рекомендуется использовать примитивные типы. Это может существенно сказаться на производительности при записи движений регистра бухгалтерии. Рекомендуется использовать только ссылочные типы.
Основным понятием бухгалтерского учета является понятие хозяйственная операция. Операцией считается любое хозяйственное действие, способное вызывать изменение состояния средств предприятия.
Для ввода информации о хозяйственных операциях в системе «1С:Предприятие» используются документы. Документ позволяет занести в систему информацию о хозяйственной операции, зафиксировать дату и время совершения операций, сумму и содержание операции.
}

}

РегистрСведений{
	Основная задача регистра сведений - хранить существенную для прикладной задачи информацию, состав которой развернут по определенной комбинации значений и, при необходимости, развернут во времени. Регистры сведений информация в которых развернута во времени, называются периодическими.

	Уникальность записей по набору измерений принципиально отличает регистры сведений от регистров накоплений, которые позволяют вводить несколько записей с одинаковым значением измерений и периодом.

	Для непериодического регистра можно получить только последнее введенное значение ресурсов регистра.
	Для периодических регистров нельзя получить значение с периодичностью меньшей, чем установленная периодичность регистра. 
	
	Главное отличие периодического регистра сведений от обычного заключается в том, что в нем присутствует дополнительное системное измерение "Период", имеющее тип "дата". Это позволяет получать не только текущие сведения об объекте, но также на любой момент времени.
	
	Если для регистра выбрана периодичность по позиции регистратора, то в уникальный ключ по измерениям входит и регистратор, как дополнительная детализация периода в пределах секунды.
	Периодичность "По позиции регистратора" следует использовать осторожно из-за сложного запроса получения среза. Если согласно закладываемой логике два документа, в одну и ту же секунду, НЕ могут сделать запись с одинаковыми значениями измерений, то использование этой периодичности является избыточным.
	
	Если режим записи независимый, то его можно редактировать вручную. Если подчинен регистратору- то у документа можно через конструктор движений делать движение и форма записи становиться недоступно, одну запись нельзя удалить/изменить.
	
	ВАЖНО: Менеджер записи не может быть использован для регистра с режимом записи "Подчинение регистратору". Такую ошибку 1С выдаст, если попробовать так записать движение{
	Запись=РегистрыСведений.ИсторияОкраски.СоздатьМенеджерЗаписи();
	Запись.Период=Дата;
	Запись.Пользователь=ПараметрыСеанса.Пользователь;
	Запись.Номенклатура = Номенклатура;
	Запись.Цвет = Цвет;
	Запись.Записать(Ложь);	
		
	В первой же строке даст ошибку.
	}

Создаем запись для подчиненного регистратору по позиции регистратора{
	НовыйНаборЗаписей = РегистрыСведений.ИсторияОкраски.СоздатьНаборЗаписей(); //для подчиненного именно набор записей.
	НовыйНаборЗаписей.Отбор.Регистратор.Установить(Ссылка); //не установишь ссылку-крякнет.
	Запись=НовыйНаборЗаписей.Добавить();
	Запись.Период=Дата;
	Запись.Пользователь=ПараметрыСеанса.Пользователь;
	Запись.Номенклатура = Номенклатура;
	Запись.Цвет = Цвет;
	НовыйНаборЗаписей.Записать(Ложь); //чтобы не перезаписывались.
}

Создаем запись для переодического независимого{
	Запись=РегистрыСведений.ИсторияОкраски.СоздатьМенеджерЗаписи();
	Запись.Период = Дата;
	Запись.Пользователь=ПараметрыСеанса.Пользователь;
	Запись.Номенклатура = Номенклатура;
	Запись.Цвет = Цвет;
	Запись.РучнойРегистратор=Ссылка;
	Запись.Записать();
}	
	
Есть регистр подчиненный регистратору с переодичностью по секунде, если есть такие измерения, то будет ошибка. На ресурсы пофиг.
	
Изменяем запись подчиненного регистратору{
Чтобы изменить записи регистра необходимо:
	создать набор записей;
	установить отбор по определенному регистратору;
	прочитать набор;
	изменить записи набора;
	записать набор.
	

Список - динамический список регистра сведений
Реквизит1 - строковой реквизит с полем на форме из которого будут браться данные для замены измерения Цвет. Это измерение измениться, а все остальные окажутся такими же.
	
&НаКлиенте
Процедура ТекущияСтрока(Команда)
	Структура=Элементы.Список.ТекущиеДанные;
	ТекущияСтрокаНаСервере(Структура);
	//В структуре храняться все поля текущей записи
КонецПроцедуры
	
	
&НаСервере
Процедура ТекущияСтрокаНаСервере(Структура)
	НаборЗаписей=РегистрыСведений.ИсторияОкраски.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Регистратор.Установить(Структура.Регистратор);
	НаборЗаписей.Прочитать();
	Для каждого запись из НаборЗаписей цикл
		Если Структура.Номенклатура=запись.Номенклатура
			и Структура.НомерСтроки=запись.НомерСтроки
			и Структура.Период= запись.Период
			и Структура.Пользователь=запись.Пользователь
			и Структура.Регистратор=запись.Регистратор
			и Структура.Цвет=   запись.Цвет
		тогда
			Запись.Цвет=Реквизит1;
		КонецЕсли;
	КонецЦикла;
	НаборЗаписей.Записать(Истина);
	Элементы.Список.Обновить();
КонецПроцедуры
	
}
	
Для изменения записей регистров, подчиненных регистраторам, используются наборы записей. При этом всегда используется отбор по регистратору. То есть совокупность записей, подчиненных одному регистратору, является "гранулой" изменения регистра. Нельзя добавлять или удалять отдельные записи. Можно только считывать и записывать записи по регистратору. 	
	
При изменении записей регистра можно использовать набор записей, входящий в коллекцию движений документа (свойство Движения объекта ДокументОбъект). Однако это не обязательно. Для изменения записей регистра можно использовать и набор записей созданный с помощью менеджера регистра.	

Удаление текущей записи подчиненного регистратору{
&НаКлиенте
Процедура Удалить(Команда)
	Структура=Элементы.Список.ТекущиеДанные;
	УдалитьНаСервере(Структура);
КонецПроцедуры


&НаСервере
Процедура УдалитьНаСервере(Структура)
	НаборЗаписей=РегистрыСведений.ИсторияОкраски.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Регистратор.Установить(Структура.Регистратор);
	НаборЗаписей.Прочитать();
	Если НаборЗаписей.Количество()>=1 тогда
	Для каждого запись из НаборЗаписей цикл
		Если Структура.Номенклатура=запись.Номенклатура
			и Структура.НомерСтроки=запись.НомерСтроки
			и Структура.Период= запись.Период
			и Структура.Пользователь=запись.Пользователь
			и Структура.Регистратор=запись.Регистратор
			и Структура.Цвет=   запись.Цвет
		тогда
			НаборЗаписей.Удалить(запись);//Удобное удаление записи
			прервать;
		КонецЕсли;
	КонецЦикла;
	НаборЗаписей.Записать(Истина);
	Элементы.Список.Обновить();
	КонецЕсли;
КонецПроцедуры
}	

В регистрах расчетов кроме отбора по регистратору для набора записей можно также установить отбор по другим значениям измерений (только по равенству). Это позволяет выполнить изменение части записей, подчиненных одному регистратору.	
Для регистров сведений, для которых в Конфигураторе установлен режим записи "Подчинение регистратору", отбор возможен только по регистратору, для периодических регистров сведений отбор возможен по периоду и значениям измерений, для непериодических - только по значению измерений.

Объект РегистрСведенийМенеджерЗаписи используется для работы с независимыми регистрами сведений (не подчиненными регистратору). Можно сказать, что данный объект является вспомогательным. 	
Основным объектом, предназначенным для модификации записей регистра сведений, является РегистрСведенийНаборЗаписей. Он позволяет считывать и записывать группы записей, отобранные по значениям измерений и периоду (для периодических регистров сведений). В модуле набора записей имеются обработчики событий, позволяющие контролировать все операции изменения данных регистра.	
Объект РегистрСведенийМенеджерЗаписи используется в тех случаях, когда необходимо выполнить операцию только над одной записью. При этом менеджер записи использует для выполнения записи два набора записей, устанавливая им соответствующие значения отборов. Поэтому обработчики событий набора записей вызываются и тогда, когда для записи данных используется менеджер записи. 	


Отличия ресурсов от реквизитов на уровне хранения данных отсутствуют, это сугубо логическое разделение. Предполагается, что реквизит это некая дополнительная информация, а ресурс - основное значение, которое нам и требуется хранить в разрезе комбинаций измерений.
Отличие измерений от ресурсов и реквизитов в том, что измерения в полном составе присутствуют во всех индексах таблицы. Порядок следования измерений в индексе такой же, как в конфигураторе. Если у ресурса (реквизита) установлено свойство "Индексировать", то будет создан индекс, в котором на первом месте этот ресурс (реквизит), а далее все наши измерения. Установить свойство "Индексировать" можно и у измерения, в этом случае будет создан дополнительный индекс, в котором на первом месте "проиндексированное" поле, а следом за ним оставшиеся измерения.

У регистров сведений есть две галочки в конце: "Разрешить итоги: срез первых" и "Разрешить итоги: срез последних". Они формируют отдельные таблицы. Если копатся в истории, брать срез последних на такую-то дату, то эти таблицы бесполезны. Срез последних просто хранит самое последнее значение, которое при записи в регистр автоматически обновляется. И в запросе его не надо будет рассчитывать. В срезе последних будет хранится значение на дату 2999 или 3999 год. Если устанавливать там какие-то даты в параметрах, то она зря место на диске занимает.
}

Разница между регистрами{
	В регистре накопления ресурс это только число.
	В регистре сведений ресурс может быть почти чем угодно (Строка, число, ссылка, булево, дата.
	Регист сведений имеет особое свойство, не используемое в других видах регистров — периодичность.
	Регистр сведений имеет автоматический контроль уникальности записей по периоду (периодичность, указанная в свойствах регистра) и измерениям. То есть среди записей регистра не может быть более одной записи с одинаковыми показателями период+измерение+регистратор(если он есть).
}

Периодические расчеты{
Периодические расчеты - это вычисления, осуществляемые с определенной периодичностью, тесно связанные друг с другом по некоторым правилам и взаимно влияющие друг на друга в пределах некоторого периода.
Основа: Планы видов расчета и Регистры расчета.
}

Система оповещений{
Можно послать оповещение всем созданным формам и всем подключенным через метод "ПодключитьОбработчикОповещения" клиентским экспортируемым процедурам модуля управляемого приложения или общего модуля. Если для формы задана процедура-обработчик события "ОбработкаОповещения", то она будет запущена, в процедуру будут переданы указанные параметры.

Оповестить(<ИмяСобытия>, <Параметр>, <Источник>)
	//В форме на команду прикрепляем: Оповестить("ЯНажалКнопкуОтправкиСигнала",Параметры,ЭтаФорма);

При начале работы вешаем на ГЛОБАЛЬНЫЙ КЛИЕНТСКИЙ модуль ЭКСПОРТНУЮ процедуру:
	ПодключитьОбработчикОповещения(<ИмяПроцедуры>) 
		//ПодключитьОбработчикОповещения("глОбработкаОповещения");
В модуле создаем процедуру с таким же именем:
	//Процедура глОбработкаОповещения(Событие, Параметр, Источник) Экспорт
Можно в открытой форме определить: ОбработкаОповещения - событие формы, и все формы такого типа будут получать сообщения. Так реализовать связь между формами.
}

КопиПаста{
ПредопределенноеЗначение("Перечисление.Важность.Важно")

Как в форме списка показать изображение товара?{
Чтобы вывести картинку в поле формы типа Картинка, нужно получить навигационную ссылку на реквизит объекта, хранящий данные картинки, функцией ПолучитьНавигационнуюСсылку(), и записать ее в строковой реквизит формы, связанный с полем картинки в форме.
	&НаКлиенте
	Процедура СписокПриАктивизацииСтроки(Элемент)
	Если ОтображатьКартинки Тогда
		АдресКартинки = ПолучитьНавигационнуюСсылку(Элементы.Список.ТекущаяСтрока, "ДанныеФайлаКартинки");
	КонецЕсли;
	КонецПроцедуры 
}

Картинку выбираем{
	&НаКлиенте
	Процедура КартинкаИзФайла(Команда)
		ДиалогОткрытияФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
		Оп = Новый ОписаниеОповещения("ОбработкаВыбораДиалога", ЭтотОбъект);
		ДиалогОткрытияФайла.Фильтр = "(*.png)|*.png";
		ДиалогОткрытияФайла.МножественныйВыбор=ложь;
		ДиалогОткрытияФайла.Показать(Оп);
	КонецПроцедуры

	&НаСервере
	Процедура ОбработкаВыбораДиалога(ВыбранныеФайлы,ДополнительныеПараметры)
	Если ВыбранныеФайлы=Неопределено тогда
		сообщить("Ничего не выбрано");
		Возврат;
	КонецЕсли;
	PictureName=ВыбранныеФайлы[0];
	PictureName=Лев(PictureName,СтрНайти(PictureName, ".png",НаправлениеПоиска.СКонца)-1)  ;
	НайденныйИндекс=СтрНайти(PictureName, "\",НаправлениеПоиска.СКонца);
	Если НайденныйИндекс<>0 тогда
		PictureName=Сред(PictureName,НайденныйИндекс+1);
	КонецЕсли;
	МояКартинка = Новый Картинка(ВыбранныеФайлы[0]);
	ГдеХранитьКартинку=Справочники.ViewFile.СоздатьЭлемент();
	ГдеХранитьКартинку.Владелец=Объект.Ссылка;
	ГдеХранитьКартинку.Хранилище=Новый ХранилищеЗначения(МояКартинка);
	ГдеХранитьКартинку.ИмяФайла=PictureName;
	ГдеХранитьКартинку.Записать();
	КонецПроцедуры
}//EndRegion "Картинку выбираем"
	
Добавляем поле программно и команду{
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
    МоиРеквизиты = Новый Массив;
    ТипСтрока = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки());
    МоиРеквизиты.Добавить(Новый РеквизитФормы("ОписаниеОбъекта", ТипСтрока, "", "Описание объекта", Ложь));
    ИзменитьРеквизиты(МоиРеквизиты);
    Команда = Команды.Добавить("ИзменитьСтроку");
    Команда.Действие = "ОбработчикПрограммныхКоманд";
    Команда.Заголовок = "Изменить строку";
    Элемент = Элементы.Добавить("ОписаниеОбъекта", Тип("ПолеФормы"));
    Элемент.Вид = ВидПоляФормы.ПолеВвода;
    Элемент.ПутьКДанным = "ОписаниеОбъекта";
    Элемент = Элементы.Добавить("ИзменитьСтроку", Тип("КнопкаФормы"));
    Элемент.ИмяКоманды = "ИзменитьСтроку";
КонецПроцедуры
...
&НаКлиенте
Процедура ОбработчикПрограммныхКоманд(Команда)
    ЭтотОбъект.ОписаниеОбъекта = "Описание объекта, сформированное командой";
КонецПроцедуры	
}

Примеры программной работы с динамическим списком{
// СписокТоваров - реквизит формы типа ДинамическийСписок
// Параметры.Склад и Параметры.ВидЦен - параметры формы соответствующих типов
&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
    СписокТоваров.Параметры.УстановитьЗначениеПараметра("Склад", Параметры.Склад);
    СписокТоваров.Параметры.УстановитьЗначениеПараметра("ВидЦен", Параметры.ВидЦен);
КонецПроцедуры	
	
	
Отбор:
Функция ДобавитьОтбор(СписокОтборов, ИмяПоля, Значение, ВидСравнения = Неопределено, Использование = Истина)
    НовыйЭлемент = СписокОтборов.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
    НовыйЭлемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
    НовыйЭлемент.ВидСравнения = ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения);
    НовыйЭлемент.ПравоеЗначение = Значение;
    НовыйЭлемент.Использование = Использование;
    Возврат НовыйЭлемент;
КонецФункции
// ДинамическийСписок - реквизит формы типа "ДинамическийСписок"
// В списке должна быть колонка "Контрагент"
//
// Выполняется установка отбора по полю "Контрагент", значение
// отбора находится в переменной "КонтрагентСсылка", отбор включен,
// условие отбора - равно.
ДобавитьОтбор(ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор, "Контрагент", КонтрагентСсылка);

Удаление:
Функция УдалитьОтбор(СписокОтборов, ИмяПоля = "")
    Если ПустаяСтрока(ИмяПоля) Тогда
        СписокОтборов.Элементы.Очистить();
        Возврат Истина;
    КонецЕсли;
    Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
    ОтборУдален = Ложь;
    Для каждого ЭлементОтбора Из СписокОтборов.Элементы Цикл
        Если ЭлементОтбора.Использование И ЭлементОтбора.ЛевоеЗначение = Поле Тогда
            СписокОтборов.Элементы.Удалить(ЭлементОтбора);
            ОтборУдален = Истина;
        КонецЕсли;
    КонецЦикла;
    Возврат ОтборУдален;
КонецФункции
// ДинамическийСписок - реквизит формы типа "ДинамическийСписок"
//             В списке должна быть колонка "Контрагент"
// Выполняется удаление отбора по полю "Контрагент".
Результат = УдалитьОтбор(ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор, "Контрагент");
Группировка:
Функция ДобавитьГруппировку(СписокГруппировок, ИмяПоля, Использование = Истина, ТипГруппировки = Неопределено)
    Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
    НовыйЭлемент = СписокГруппировок.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
    НовыйЭлемент.Использование = Использование;
    НовыйЭлемент.Поле = Поле;
    НовыйЭлемент.ТипГруппировки = ?(ТипГруппировки = Неопределено, ТипГруппировкиКомпоновкиДанных.Элементы, ТипГруппировки);
    Возврат НовыйЭлемент;
КонецФункции
// ДинамическийСписок - реквизит формы типа "ДинамическийСписок"
// В списке должна быть колонка "Контрагент"
//
// Выполняется создание группировки по полю "Контрагент", созданная
// группировка будет использоваться, тип группировки - только элементы
Группировка = Список.КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
ДобавитьГруппировку(Группировка.ПоляГруппировки, "Контрагент");
}

Условное оформление{
Функция УстановитьУсловноеОформление(СписокОформления, ИменаОформляемыхПолей, СтруктураОформление, Использование = Истина) Экспорт
    НовыйЭлемент = СписокОформления.Элементы.Добавить();
    НовыйЭлемент.Использование = Использование;
    // Зададим оформляемые поля, заданные массивом с именами полей
    Для каждого ИмяПоля Из ИменаОформляемыхПолей Цикл
        ОформляемоеПоле = НовыйЭлемент.Поля.Элементы.Добавить();
        ОформляемоеПоле.Использование = Истина;
        ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
    КонецЦикла;
    // Зададим оформление, заданное структурой,
    // в которой - Ключ: имя параметра оформления,
    //    а Значение - значение параметра оформления
    Для каждого ЭлементОформления Из СтруктураОформление Цикл
        НовыйЭлемент.Оформление.УстановитьЗначениеПараметра(ЭлементОформления.Ключ, ЭлементОформления.Значение);
    КонецЦикла;
    Возврат НовыйЭлемент;
КонецФункции	
	
	
	ЭлементыУсловногоОформления = Список.КомпоновщикНастроек.ФиксированныеНастройки.УсловноеОформление;
ОформляемыеПоля = Новый Массив;
ОформляемыеПоля.Добавить("Сумма");
ОформляемыеПоля.Добавить("Организация");
// ***** Установка красного цвета для суммы менее 500
Оформление = Новый Структура;
Оформление.Вставить("ЦветТекста", Новый Цвет(128,0,0));
НовыйЭлемент = УстановитьУсловноеОформление(ЭлементыУсловногоОформления, ОформляемыеПоля, Оформление);
// Зададим условие оформления: Сумма < 500
ДобавитьОтбор(НовыйЭлемент.Отбор, "Сумма", 500, ВидСравненияКомпоновкиДанных.Меньше);
// ***** Установка зеленого цвета для суммы более 10 000
Оформление = Новый Структура;
Оформление.Вставить("ЦветТекста", Новый Цвет(0,128,0));
НовыйЭлемент = УстановитьУсловноеОформление(ЭлементыУсловногоОформления, ОформляемыеПоля, Оформление);
Зададим условие оформления: Сумма > 10 000
ДобавитьОтбор(НовыйЭлемент.Отбор, "Сумма", 10000, ВидСравненияКомпоновкиДанных.Больше);
// установка синего цвета, если сумма в интервале от 500 до 10 000
Оформление = Новый Структура;
Оформление.Вставить("ЦветТекста", Новый Цвет(0,0,128));
// Передача пустого массива в качестве списка оформляемых полей
// означает оформление всех полей строки
НовыйЭлемент = УстановитьУсловноеОформление(ЭлементыУсловногоОформления, Новый Массив, Оформление);
// Cоздадим группу условий "И"
ГруппаОтборов = НовыйЭлемент.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
ГруппаОтборов.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
// Зададим условие оформления: Сумма > 500 И Сумма < 10 000
ДобавитьОтбор(ГруппаОтборов, "Сумма", 500, ВидСравненияКомпоновкиДанных.Больше);
ДобавитьОтбор(ГруппаОтборов, "Сумма", 10000, ВидСравненияКомпоновкиДанных.Меньше);
}


}//EndRegion "КопиПаста"

Боль{

C клиента можно вызвать серверную процедуру общего модуля только если у модуля стоит ТОЛЬКО СЕРВЕР и ВЫЗОВСЕРВЕРА и экспорт.
 
ДанныеВыбора и уникальное наименование{
Нужен был уникальный реквизит наименование. Код нужен был для автонумерации. А наименование идеально подходит.
Задумка-Вводим текст, и в обработке введенного, которая возникает при нажатии куда-то за пределы поля, или клавиши энтер, проверяем, есть ли такое значение. Если есть то в идеале выставляем подсказку, типо как пометкаОнезаполненном.-Все идеально работает, кроме одного- когда я отключил СтандартнаяОбработка, произошло забавная вещь, описанная в синтаксис помошнике:
	Для типов Число, Строка, Дата, если установить данному параметру значение Истина, то выполняется стандартное присвоение значения на основе введенного текста, без использования значения параметра <ДанныеВыбора>. В противном случае поле ввода обрабатывает получаемый в <ДанныеВыбора> список значений аналогично другим типам.
При клике в другое место, появляется ВиджетВыбора. Ввел что-то не то, поле очищается и все равно выскакивает ВиджетВыбора, так как он пустой, то в нем нет этого значения, и тяжело избавляться от его надписи "<ВведенныйТекст> не найден". Однако, если в в данныеВыбора передать такое же значение, как и в объект.наименование, то он не появляется, и все работает идеально:
&НаКлиенте
Процедура НаименованиеОкончаниеВводаТекста(Элемент, Текст, ДанныеВыбора, ПараметрыПолученияДанных, СтандартнаяОбработка)
	СтандартнаяОбработка=Ложь;
	Если ПроверкаУникальностиНаименование(Текст) тогда
		Объект.Наименование=Текст;
		СписокЗначений=Новый СписокЗначений;
		СписокЗначений.Добавить(Текст,Текст);
		ДанныеВыбора=СписокЗначений;
	иначе
		Элементы.Наименование.ПодсказкаВвода="Такой уже существует";
		СписокЗначений=Новый СписокЗначений;
		СписокЗначений.Добавить("","");
		ДанныеВыбора=СписокЗначений;
		Объект.Наименование="";                             
	КонецЕсли;
КонецПроцедуры
}//EndRegion "ДанныеВыбора и уникальное наименование"

УсловноеОформление{
Условное оформление по сути работает только для динамических списков и таблиц. К обычным реквизитам его не подогнать.

Есть форма. У форма созданы два реквизита ТаблицыЗначений:
	Найденные
		Счет
		Вин
		Звонки
	РеквВыбранныеЗвонки
		Звонок
Для каждого из этих ТаблицаЗначений созданы элементы:
	НайденныеЭлем
	ВыбранныеЗвонкиЭлем
Установим УсловноеОфомление:
	Когда устанавливаем оформляемое поле-берем Элемент формы, а когда делаем отбор-берем значение реквизита.
	
ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();
ОформляемоеПоле = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
ОформляемоеПоле.Поле = Новый ПолеКомпоновкиДанных("НайденныеЭлем");//Тут указываем именно название элемента. 
ЭлементОтбора = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Найденные.Звонки");//Тут указываем название реквизита.
ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
ЭлементОтбора.ПравоеЗначение = <Или другое значение, допустим 5, или другое поле, типо Новый ПолеКомпоновкиДанных("Найденные.Звонки")>;
ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", WebЦвета.Зеленый);
	
}//EndRegion "УсловноеОформление"

Json{
В 1С идет запись в json в таком же явном виде, как процедуры, как циклы:

файл=Новый ЗаписьJSON();
параметрыЗапись=Новый ПараметрыЗаписиJSON(,Символы.Таб,,,,,,,);
файл.ОткрытьФайл("W:\file\file.json",,,параметрыЗапись);
Есть массив, это []
и есть объект-словарь, это {}. По сути начало объекта это по идее {, а конецОбъекта это }.
Теперь явно создаем объект или массив и в него записываем:

файл.ЗаписатьНачалоОбъекта();
	файл.ЗаписатьИмяСвойства("eng"); //eng::"Что то там"  //в таком духе будет записано.
	файл.ЗаписатьЗначение(англ);
	
	файл.ЗаписатьИмяСвойства("AllRu");	//ключ, по которому будет обращяться к массиву.
		файл.ЗаписатьНачалоМассива();
		Для каждого перевод из МассивВСехВозможныхПереводов цикл
			файл.ЗаписатьЗначение(перевод);		
		КонецЦикла;
		файл.ЗаписатьКонецМассива();

файл.ЗаписатьКонецОбъекта();
файл.Закрыть();	
}//EndRegion "Json"

По непонятной причине, чтобы получить общий макет надо использовать ПолучитьОбщийМакет(<ОбщийМакет>), просто так его не получить.

Поле HTML документа{
html5 отсутствует, es5 тоже. Нужно все писать в соотвествии с es3 от 1999 года для IE5. Поддержка DOM api не поддерживаеь поиск по селекторам.
формс=Элементы.<РеквизитПолеHtml>.Документ;
сообщить(формс.forms["<ИмяНужнойФормы>"].<Input1>.Value);

Пример:
формс=Элементы.Док.Документ;
формс.forms["vasa"].input1.Value = "ООО Вперед";
формс.forms["vasa"].input2.Value = "директору";

В документации написано:
https://its.1c.ru/db/v8312doc#bookmark:dev:TI000001764
ПРИМЕЧАНИЕ. Следует учитывать, что при использовании поля HTML-документа может не обеспечиваться поддержка всей функциональности HTML. В частности, не поддерживаются скрипты с состоянием (переменные, хранящие значения, необходимые в различных обработчиках событий), работа с языком разметки SVG, свойство HTML-документа parentWindow, переходы по ссылке внутри отображаемой страницы. Ограничения могут быть обусловлены специфическими особенностями функционирования HTML (в том числе и неидентичное функционирование) в формах «1С:Предприятия» в клиентских приложениях и в различных веб-браузерах.
}

Чат в 1С{
	Справочник Пользователи. Для сопоставления пользователей:
		Параметр сеанса ТекущийПользователь. Ссылка на соответствующего пользователя в справочнике Пользователи.
		Реквизит Ответственный в каждом документе. Ссылка на соответствующего пользователя в справочнике Пользователи.
	Будет выглядеть так:{
Процедура УстановкаПараметровСеанса(ТребуемыеПараметры)
	ТекПользователь=Справочники.СписокПользователей.НайтиПоНаименованию(ИмяПользователя());
	Если ТекПользователь.Пустая() тогда
		НовПользователь=Справочники.СписокПользователей.СоздатьЭлемент();
		НовПользователь.Наименование=ИмяПользователя();
		НовПользователь.Записать();
		ТекПользователь=НовПользователь.Ссылка;
	КонецЕсли;
	ПараметрыСеанса.ПараметрСеансаПользователь=ТекПользователь;		
КонецПроцедуры
		
	}

	




	
}

Регулярные выражения в Windows{
	Книга Михайлов А. Системное программирование в 1С: Предприятии 7.7/8.0 (Глава 1. "Применение технологий СОМ и ActiveX" - "Регулярные выражения")
Библиотека RegExp является предустановленной т.е. есть в любом Windows
Регулярные выражения являются частью технологии Microsoft Windows Script Technologies и входят в VBScript.
Нужно:
		 vbscript.dll. Данная библиотека включена в Internet Explorer 4 и выше.
Метасимволы:
* - выражение до знака ноль или более раз: "[0-9]*" - в строке ноль или больше нуля цифр.
\ - экранирование символов: "." - любой символ "\." - точка.
^ - начало входной строки
$ - конец входной строки.
+ - выражение до знака + один или более раз: "[0-9]+" - в строке одна или больше цифр.
. - любой символ кроме символа перевода строки.
| - или. "a|b" - подходят строки "а" и "b". " (два | три) богатыря" "два богатыря", так и "три богатыря".
[a-z] - определяет диапазон символов: "[0-9]" - определяет цифру.
[^.-.] - определяет любой символ, не соответствующий набору: "[^0-9]" - любой символ, кроме цифры.
\w - Слово. То же, что и [a-zA-z_0-9].
\W - Все, кроме слов. То же, что и [^a-zA-z_0-9]
\s - Любое пустое место.
\S - Любое непустое место.
\d - Десятичная цифра, то же, что и [0-9]
\D - Не цифра. То же что и [^0-9]
{} - в скобках кол-во символов, подходящих по описанное ранее правило.
() - объединение метасимволов в группы.
()\1 - повторение того, что группа в скобках повторяется еще раз.
Подробнее:
«gray|grey» и «gr(a|e)y» - оба описывают множество, содержащее gray и grey.
{n,m} - общее выражение, повторений может быть от n до m включительно.
{n,} - общее выражение, n и более повторений.
{,m} - общее выражение, не более m повторений.
{n} - общее выражение, ровно n повторений
 ? - Знак вопроса означает 0 или 1 раз, то же самое, что и {0,1}. Например, «colou?r» соответствует и color, и colour.
+ - Плюс означает хотя бы 1 раз ({1,}). Например, «go+gle» соответствует gogle, google и т. д. (но не ggle).

Создаем СОМ-объект с идентификатором VBScript.RegExp.
Объект RegExp имеет следующие свойства:
	Global — признак поиска соответствия во всей строке, причем если
свойство принимает значение истина, то поиск ведется во всей строке,
если ложь — то только до первого совпадения;
	ignorecase — признак игнорирования регистра символов при поиске
(свойство может принимать значение истина и ложь);
	Pattern — строковый шаблон для поиска;
	MultiLine — признак, является ли текст многострочным или нет (свойство
может принимать значение истина и ложь)
Методы:
	Test (ИсходнаяСтрока) — метод Test позволяет протестировать строку
исходнаяСтрока на соответствие ее шаблону (pattern). Возвращает значение
истина, если строка, переданная в качестве параметра, соответствует
определенному шаблону, ложь — иначе.
	Execute (ИсходнаяСтрока) — метод выполняет поиск всех совпадений
регулярного выражения в строке исходнаяСтрока и возвращает коллекцию
MatchCoiiection, которая содержит в себе всю информацию о совпадениях.
Метод Execute может быть использован, например, для извлечения
всех e-mail-адресов из строки ИсходнаяСтрока.
	 Replace(ИсходнаяСтрока, НоваяСтрока) — МСТОД Replace дает ВОЗМОЖНОСТЬ
заменить все совпадения регулярного выражения строкой новаяСтрока.

Пример:
РегулярноеВыражение = "<BODY (.*)</BODY>";
ТестоваяСтрока = "<HTMLXBODY bgcolor=#FFAABBXP>3TO пример</РХ/ВОО¥>
</HTML>";

	RegExp = Новый СОМОбъект("VBScript.RegExp");
	RegExp.MultiLine = Ложь;
	RegExp.Global = Истина;
	RegExp.IgnoreCase = Истина;
	RegExp.Pattern = РегулярноеВыражение;
	// Поиск совпадений регулярного выражения в строке
	Matches = RegExp.Execute(ТестоваяСтрока);
	// Обход элементов коллекции MatchCollection
	Для каждого Match Из Matches Цикл
		Сообщить("Номер первого совпавшего символа: " + Match.Firstlndex);
		Сообщить("Длина совпавшего образца: " + Match.Length);
		Сообщить("Первый совпавший образец: " + Match.SubMatches(0));
		Сообщить("Полный образец: " + Match.Value);
	КонецЦикла;
	
	свойство Firstlndex - определяет номер первого совпавшего
символа
	свойство Length - определяет длину совпавшего образца;
	SubMatches(0) - первым совпавшим образцом, т. е. текст, попавший в скобки "(•*)" в шаблоне
(для второго совпадения нужно выполнить метод SubMatches (i) и т. д.);
	
	
	
	
	
	
	
	
}

Excel в Windows{
	Попытка 
		Excel = Новый COMОбъект("Excel.Application"); 
	Исключение 
		Сообщить("Не удалось инициализировать Excel"); 
		Возврат; 
	КонецПопытки;
	
	Попытка
		Excel.Application.Workbooks.Open(ФайлЗагрузки);
	Исключение	
		Предупреждение(ОписаниеОшибки());
		Excel.Quit();
		Excel=Неопределено;				
		Возврат;
	КонецПопытки;
	
	Зн = Excel.ActiveSheet.Cells(НомерСтроки,НомерКолонки).Value;
	
	Возможно:
		Книга=Excel.Workbooks.Add () 'Создаем новую книгу
		Лист=Книга.Worksheets.Add() ' Создаем новый лист
		
		Excel.Workbooks.SaveAs( FileName , FileFormat , Password , WriteResPassword , ReadOnlyRecommended , CreateBackup , AccessMode , ConflictResolution , AddToMru , TextCodepage , TextVisualLayout , Local )
}

Поиск в таблице в управляемой форме{
Для управления возможностями поиска в динамическом списке предназначены три свойства таблицы управляемой формы, отображающей динамический список:
	1-Положение строки поиска ‑ определяет положение строки поиска. Может принимать следующие значения: Авто, Командная панель, Нет, Верх, Низ.
	2-Положение состояния просмотра ‑ описывает, где будет отображаться состояние просмотра: по каким полям выполнялся поиск и какие значения искались в каждом поле. Может принимать следующие значения: Авто, Нет, Верх, Низ.
	3-Положение управления поиском ‑ определяет, где будет отображаться кнопка управления поиском. Кнопка открывает меню, которое содержит следующую информацию: команды Найти по текущему значению, Расширенный поиск, Отменить поиск, Установить период (для списков документов и журналов) и история поисковых запросов (последние 5 запросов). Свойство может принимать значения: Авто, Нет, Командная панель.
Динамический список идет в элементе формы Таблица. И табличная часть документа и справочника идет в нем же. У любого элемента Таблица есть эти свойства. Только у динамического списка они работают, а у документа нет.
}

Проверка уникальности при записи{
Созданем регистр сведений, непереодический. У которого измерения СправочникТовар(Наименование) и СправочникАналог (Основа). У Справочника Аналог есть реквизит Товар (Товар)
Отбор=Новый Структура;
Отбор.Вставить("Наименование",Товар);
Выборка=РегистрыСведений.РегистрСведений1.Выбрать(Отбор);
ЕстьЛиТакойЖе=Выборка.Следующий();
Если не ЕстьЛиТакойЖе тогда
	Регистр=РегистрыСведений.РегистрСведений1.СоздатьМенеджерЗаписи();
	Регистр.Основа=Ссылка;
	Регистр.Наименование=Товар;
	Регистр.Записать();
	сообщить("Успешно записан");
Иначе
	Отказ=Истина;
	сообщить("Такой уже есть"+Строка(Выборка.Основа));
КонецЕсли;

}

Выпадающий список в управляемой форме{
В управляемой форме есть методы: ПоказатьВыборИзСписка (ShowChooseFromList) и ПоказатьВыборИзМеню (ShowChooseFromMenu). При нажатии допустим на команду, появиться этот список и в из него можно будет выбрать значение. И ты сам выбираешь, возле какого элемента появиться этот список:
	Список = Новый СписокЗначений;
	Список.Добавить("Доставка");
	Список.Добавить("Разгрузка");
	Список.Добавить("Картинка");
	Оп = Новый ОписаниеОповещения("ПослеВыбораИзМеню", ЭтотОбъект);
	ПоказатьВыборИзСписка(Оп, Список, Элементы.Код);
И возле элемента формы Код появиться такой список.

Можно использовать внутри табличного документа, для привязки к области ТабДок.
&НаКлиенте
Процедура ТабДокВыбор(Элемент, Область, СтандартнаяОбработка)
	Если Область.Имя="R2C1" тогда
		СписокЗначений=Новый СписокЗначений;
		СписокЗначений.Добавить("Ключ1","ЗначениеКлюча1");
		СписокЗначений.Добавить("Ключ2","ЗначениеКлюча2");
		ПоказатьВыборИзМеню(Новый Описаниеоповещения("СделанВыбор",ЭтотОбъект,), СписокЗначений, ТабДок.Область("R2C1")); 
	КонецЕсли;
КонецПроцедуры
&НаКлиенте
Процедура СделанВыбор(ВыбранноеЗначение,Параметры) Экспорт
//do something
КонецПроцедуры

Процедура должна быть экспортной.
}

Поле Календаря{
У элемента формы связанного с реквизитом типа Дата выбирает Вид Поле календаря.
При создании на сервере делаем:
	Реквизит1=ТекущаяДата();
выделена в календаре этот день. Для выделения текущей недели красным:

&НаКлиенте
Процедура Реквизит1ПриВыводеПериода(Элемент, ОформлениеПериода)
	День=24*60*60;
	Старт=НачалоНедели(Реквизит1);
	Конец=Старт+День*7;
	Для каждого ТекДата Из ОформлениеПериода.Даты Цикл         
            Если ТекДата.Дата >= Старт и ТекДата.Дата < Конец Тогда            
             	ТекДата.ЦветФона = Новый Цвет(255, 0, 0);//Красный день календаря                 
        	КонецЕсли;             
    КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура Реквизит1ПриАктивизацииДаты(Элемент)
	Элементы.Реквизит1.Обновить();//Запускаем ПриВыводеПериода
КонецПроцедуры

Странная вещь поле календаря. Недели не приделать. Вызывается несколько раз. Недели криво отображаются. Если месяц начинается с черверга, то среда понедельник и вторник не буду видны - они окрасяться к другом окне-месяце. А в этом месяце они чисто серые. Вроде и есть календарь - дату выбрать удобно. А так хрень полная. Красивее и проще свой нарисовать в поле табдок.
}

Пояснение{
У каждого прикладного объекта в 1С, даже у "Подсистема" есть свойство "Пояснение", это всплывающее окошко( всплывающая подсказка), при наведении на этот объект.
Для подсистемы удобно использовать, в панели разделов, можно указать на подсистему и увидеть её описание в "пояснение".
А для объектов подсистемы их можно увидеть только в "Панели функций текущего раздела", которые я не использую.
При нажатии на подсистему, открывается окно со всеми её командами- там не работает пояснение.
}

Реквизит3=Реквизит2=Реквизит1;{
Это не равенство. Это сравнение.
Реквизит3 будет равен или "Да" если он строка, или 1 если он число, в случае если Реквизит2==Реквизит1.
В случае не равенства, он будет ноль или "Нет".
}
}//EndRegion "Боль"

Postgresql заметки{

Скачивание{
	https://postgrespro.ru/products/download
Прямо на главной странице есть ссылка на "PostgreSQL для платформы 1С" и там можем выбрать или перейти на  генератор инструкций для получения актуальной и архивных сборок PostgreSQL для 1С:
	https://postgrespro.ru/products/archive/1c
У меня получилась ссылка под виндовс х64:
	http://repo.postgrespro.ru/1c-archive/pg1c-10.4/win/PostgreSQL_1C_10.4_64bit_1C_Setup.exe
}

При установке, должна быть служба активна: "Вторичный вход в систему".
И службу "агент 1С предприятие сервер" должна быть тоже запушена. В настройках службы на второй странице ставим запуск от текущего пользователя - там есть две точки на выбор, текущий и еще какой-то с вводом пароля. Нужен верхний - текущий.

Кавычки имеют значение: " и ' это разные вещи. "-отделённые идентификаторы или идентификаторы в кавычках{
Одинарная кавычки (апостроф) это строка.
А двойная, это уже литерал, как название колонки:
	CREATE TABLE courses(
c_no text PRIMARY KEY,
"title my" text,
hours integer
);
INSERT INTO courses(c_no, "title my", hours) VALUES ('CS301', 'Áàçû äàííûõ', 30),
('CS305', 'Ñåòè ÝÂÌ', 60);
}

-- Это комментарий SQL до конца строки
/*Это многострочный комментарий в стиле С, который может быть вложеннным в другой комментарий*/

Самые первые неоформленнные заметки{
кластер PostgreSQL должен быть инициализирован с локалью ru_RU.UTF-8

Установка:
	везде далее,
	при установке параметров сервера вводим пароль и подтверждаем его.
	ставим галочку: "Настроить переменные среды", чтобы подключаться к серверу под текущим пользователем ОС
		
При установке, в системе зарегистрируется служба: postgrespro-X64-10. Она запускается автоматически при старте компьютера под учетной записью Network Service (Сетевая служба).
В меню Пуск в папке, которую указал при установке есть программа "Stop Server" и "Start Server". 
Есть консольная программа psql- в меню пуск выбираем "SQL Shell (psql)".
	Нужно ставить точку с запятой в конце команды или он думает, что продолжение команды на другой строке.
	Если команда начинется с обратной косой черты ("\") то это специальная команда только для psql. Ни pyAdmin ни прочее не понимают их-нужно для них специальные аналоги искать.
Создаем новую базу test:
CREATE DATABASE test;
Переключаемся на созданную базу:
\c test
Тут приглашение ко вводу должно смениться на имя базы.
Создадим таблицу courses с уникальными (Primary key) текстовыми номерами курса, названием курса и часами лекций:
CREATE TABLE courses(
c_no text PRIMARY KEY,
title text,
hours integer
);
Добавим в таблицу несколько строк:
INSERT INTO courses(c_no,title,hours) VALUES
("cs301","Базы данных",30),
("cs305","Сети ЭВМ",60);
Создадим две таблицы: 
	Для каждого студента с его уникальным номером студенческого билета, именем и годом поступления.
	Экзамены с оценкой по дисциплине. Она связана с таблицей студентов отношением "многие ко многим" - один студент может сдавать экзамены по многим дисциплинам, а экзамен по одной дисциплине сдают много студентов. Запись в таблице экзаменов идентифицируется совокупностью имени студента и номером курса. Ограничение целостности сразу к нескольким столбцам делается с помощью CONSTRAINT.
CREATE TABLE students(
s_id integer PRIMARY KEY,
name text,
start_year integer
);
INSERT INTO students(s_id,name,start_year) VALUES
(1451,"Анна",2014),
(1432,"Виктор",2014),
(1556,"Нина",2015);
CREATE TABLE exams(
s_id integer REFERENCES students(s_id),
c_no text REFERENCES courses(c_no),
score integer,
CONSTRAINT pk PRIMARY KEY(s_id,c_no)
);
INSERT INTO exams(s_id,c_no,score) VALUES
(1451,"CS301",5),
(1556,"CS301",5),
(1451,"CS305",5),
(1432,"CS305",5);

Выборка:
	Псевдоним:
	SELECT title AS course_title, hours FROM courses;
	Различные:
	SELECT DISTINCT start_year FROM students;
	Условие:
	SELECT * FROM courses WHERE hours >45;
	Прямое (декартовое) произведение таблиц- к каждой строке одной таблицы добавляется каждая строка другой:
	SELECT * FROM courses,exams;
	Соединение:
	SELECT courses.title, exams.s_id, exams.score FROM courses, exams WHERE courses.c_no = exams.c_no;
	Для соединения можно указывать ключевое слово JOIN:
	Студенты и их оценки по курсу "Сети ЭВМ":
	SELECT students.name, exams.score FROM students
	JOIN exams
		ON students.s_id = exams.s_id
		AND exams.c_no ="CS305";
	Тут не включаются те студенты, для строки исходной таблицы не нашлось пары в другой таблице, исключаются и студенты, которые не сдавали экзамен по этой дисциплине. Чтобы отобразить все используем операцию внешнего соединения:
	SELECT students.name, examss.score
	FROM students
	LEFT JOIN exams
	ON students.s_id = exams.s_id
	AND exams.c_no="CS305";
}
	
Подзапросы (вложенные таблицы){
Таблица, которая формируется оператором select может быть выведена в качестве результата, а может быть вставлена в любой конструкции языка SQL, где по смыслу может находиться таблица.	
	
Вложенная команда SELECT заключенная в круглые скобки называется подзапросом.
Скалярное выражение- подзапрос возвращающий одну строку и один столбец.
SELECT name,
(SELECT score FROM examps WHERE exams.s_id=students.s_id AND exams.c_no = 'CS305')
FROM students;
Если подзапрос не содержит ни одной строки, возвращается неопределенное значение.
}

Возможные рекомандации по установки 1С{
	В 1С должна быть компонента: "Сервер 1С:Предприятия" и "Администрирование сервера 1С:Предприятие".
При добавлении базы указываем:
Кластер серверов 1С:Преприятие: 192.168.1.111 это айпишник компьютера, на котором установлен сервера 1С, в нашем случаи это наш основной пк
Имя информационной базы в кластере = пишем, что хотим, если БД с таким именем не будет, создастся автоматически
Защищенное соединение = не трогаем, пока без этого обойдемся
Тип СУБ = коль установили Postgresql, тогда и выбираем данную СУБД из списка
Сервер базы данных = айпишний, тот же айпишник компьютера, на котором установлена СУБД
Имя базы данных = как назовем, так и будет называться наша БД в списке СУБД
Пользователь базы данных = да, наш пользователь из СУБД, помните, это postgres
Пароль пользователя = пароль выше упомянутого пользователя
Создать базу данных в случаи ее отсутствия = Да, ставим галку
Подключается по портам: 1541 и 1560. Смотреть, чтобы брандмаузер не заблочил их.
}

SELECT DISTINCT - различные
DROP TABLE имя_таблицы; //удаление таблицы
INSERT INTO weather (date, city, temp_hi, temp_lo) VALUES ('1994-11-29', 'Hayward', 54, 37); //вставка
ORDER BY city; //сортировка по возрастанию (по умолчанию)
ORDER BY c_no DESC, year DESC; //DESC- по убыванию. ASC- возростание
JOIN ... ON //ON = WHERE
LEFT JOIN ... ON //все из левой, для которых не нашлось пары в правой
RIGHT JOIN ... ON
price numeric CHECK (price > 0) //Ограничение-проверка
name text NOT NULL
product_no integer UNIQUE,
city char(10) CHECK (city IN ('London', 'New York', 'San Jose', 'Barselona')),
CHECK    (comm < .15 OR city = 'Barcelona')); 
_task INTEGER REFERENCES task(id),
Select EXISTS(select 1 from task where id=1);//Предикат EXISTS принимает значение TRUE, если подзапрос содержит любое количество строк
CREATE TABLE IF NOT EXISTS MainTable
COUNT(DISTINCT model)

CASE{
CASE 
	WHEN price IS NULL 
	THEN 'Нет в наличии' 
ELSE CAST(price AS CHAR(20)) 
END price 
}

HAVING -условие применяющееся после группировки{
select c_no,count(*),max(s_id) from exams GROUP BY c_no HAVING max(s_id)>1500;	
}

Изменение и удаление данных|столбцов{
UPDATE изменяет значения указанных столбцов во всех строках, удовлетворяющих условию. В предложении SET должны указываться только те столбцы, которые будут изменены; столбцы, не изменяемые явно, сохраняют свои предыдущие значения.{
UPDATE [ ONLY ] имя_таблицы [ * ] [ [ AS ] псевдоним ]
    SET { имя_столбца = { выражение | DEFAULT } |
          ( имя_столбца [, ...] ) = [ ROW ] ( { выражение | DEFAULT } [, ...] ) |
          ( имя_столбца [, ...] ) = ( вложенный_SELECT )
        } [, ...]
    [ FROM список_FROM ]
    [ WHERE условие | WHERE CURRENT OF имя_курсора ]
    [ RETURNING * | выражение_результата [ [ AS ] имя_результата ] [, ...] ]
Удвоим значение часов для курса CS301:
	UPDATE courses SET hours=hours *2 Where c_no='CS301';
	UPDATE exams SET score=7 WHERE score=5 AND c_no='CS301';
}

Оператор DELETE удаляет строки, определяемые предложением WHERE:{
	DELETE FROM exams WHERE score <5;
}

Оператор SQL ALTER TABLE используется тогда, когда необходимо внести изменения в структуру уже существующей таблицы.{
	ALTER TABLE table_name ADD column_name datatype
	ALTER TABLE students ADD g_no text REFERENCES groups(g_no);
}

}

Транзакция{
Иногда могут быть нестыковки:
Есть студент. Студент может быть старостой группы(ид группы).
Есть группа, у группы обязан быть староста(студент)
Как создать группу, если у группы должен быть староста. А назначить старостой студента нельзя, так как нет группы еще.
Получается есть две операции, которые надо совершить одновременно, и каждая не имеет смысла без другой. Эти операции едины- логическая неделимая единица работы - транзакция.
Можно сначало группе привязать студента и создать её, а потом студенту дать старосту, но тогда в несколько секунд в базе будут логически некорректные, несогласованные данные - в группе указано, что студен староста, а студент об этом не знает.
Для создания транзакции пишем:
BEGIN;
...INSERT INTO ....;
COMMIT:
Или прервать транзакцию командой: ROLLBACK;
Субд гарантирует, что или все выполниться, или база останеться в таком же состоянии, в каком находилась до команды BEGIN - это свойство субд атомарность.
Пользователь не видит несогласованные данные, которые транзакция не зафиксировала- свойство изоляция. Блокировка будет только при одновременном изменении одной и той же строки двумя разными процессами.
}

Код из книги PostgreSQL для начинающих v.4 П.Лузанов, Е.Рогов, И.Лёвшин {

/*Создание таблиц курсов:*/
CREATE TABLE courses(
	c_no text PRIMARY KEY,
	title text,
	hours integer
);

/*Вставка*/
INSERT INTO courses(c_no,title,hours) VALUES
('CS301','Базы данных',30),
('CS305','Сети ЭВМ',60);

CREATE TABLE students(
	s_id integer PRIMARY KEY,
	name text,
	start_year integer
);

INSERT INTO students(s_id,name,start_year) VALUES
(1451,'Анна',2014),
(1432,'Виктор',2014),
(1556,'Нина',2015);

CREATE TABLE exams(
	s_id integer REFERENCES students(s_id),
	c_no text REFERENCES courses(c_no),
	score integer,
	CONSTRAINT pk PRIMARY KEY(s_id,c_no)
);

INSERT INTO exams(s_id,c_no,score) VALUES
(1451,'CS301',5),
(1556,'CS301',5),
(1451,'CS305',5),
(1432,'CS305',4);

CREATE TABLE groups(
	g_no text Primary KEY,
	monitor integer NOT NULL REFERENCES students(s_id)
);

ALTER TABLE students ADD g_no text REFERENCES groups(g_no);


















}

Некоторые команды psql{
		\x - переключение вывода таблицы с табличного на расширенный.
		\L - список баз данных
		\du- список пользователей
		\dt- список таблиц
		\di- список индексов
		\dv- список представлений
		\q - завершение сеанса.
		\c ИмяБазы - Переключаемся на базу. 
		CREATE DATABASE ИмяБазы - создаем базу. 
}

Настройка pgAdmin4{
сменить язык по умолчанию (Английский на Рус):
		через меню "File" – "Preferences".
		в дереве находим Miscellaneous->"User language" меняем язык на “Russian”
		Перезапустить, чтобы изменения вступили в силу.
Для работы в 1С пользователь должен быть супер.

В pgAdmin 4 есть несколько форматов выгрузки базы в дамп:
	1. Специальный – этот формат архива рекомендуется для средних и больших баз данных, поскольку он по умолчанию сжимается.
	2. Tar –  – это файл архива, не поддерживает сжатие.
	3. “Простой” формат нужен, чтоб создать файл сценария с открытым текстом. Будет создан файл сценария с открытым текстом, который содержит инструкции и команды SQL. Файл резервной копии в  “Простом” формате можно отредактировать в текстовом редакторе при необходимости.
	4. Каталог, этот формат предназначен, чтобы создать архив в формате каталога.

Дело в том, что PostgreSQL самостоятельно не блокирует при изменении данных таблицы и записи от читающих транзакций, этим занимается сам сервер 1С «Кластер серверов». Вместо этого создаётся копия изменяемой записи, которая становится видна последующим транзакциям, действующие же продолжают видеть данные, актуальные на начало своей транзакции. И в результате, в таблицах скапливаются  устаревшие данные – предыдущие версии измененных записей.
Эти записи лишь «мусор», который скапливается в базе и зря расходует дисковое пространство.
На больших базах, с которыми интенсивно работают пользователи (где много транзакций) это хорошо заметно, базы «распухают» и падает производительность.

VACUUM  + FULL переписывает всё содержимое таблицы в новый файл на диске, не содержащий ничего лишнего, что позволяет возвратить неиспользованное пространство операционной системе. Эта форма работает намного медленнее и запрашивает исключительную блокировку для каждой обрабатываемой таблицы.
 
Индекс, он как таблица, содержит блоки со старыми версиями записей. PostgreSQL не всегда может заново использовать эти блоки, и поэтому файл с индексом постепенно увеличивается в размерах. Если данные в таблице часто меняются, то вырасти он может очень быстро.
Операция REINDEX используется для перестройки существующих индексов.
}

Небольшие возможные заметки{
PostgreSQL не умеет работать многопоточно- 1 запрос = 1 поток! (На этой СУБД). Не распараллеливается выполнение одного запроса. Нет многопоточности! в рамках одного запроса  – это одна из причин, почему PostgreSQL работает медленнее MS SQL. Один большой запрос может стать «узким местом» в производительности вашей 1С на этой СУБД.

pg_dump – это утилита позволяющая делать бэкап базы данных из postgresql.

pg_dumpall – используется для бэкапа всего кластера, утилита создает резервную копию всех баз данных, а также сохраняет данные уровня кластера, такие как роли и определения табличных пространств, одним словом все.

}

Создание таблиц - значения по умолчанию и автонумерация{
Если значение по умолчанию не объявлено явно, им считается значение NULL. Обычно это имеет смысл, так как можно считать, что NULL представляет неизвестные данные.
В определении таблицы значения по умолчанию указываются после типа данных столбца. Например:
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric DEFAULT 9.99
);
Значение по умолчанию может быть выражением, которое в этом случае вычисляется в момент присваивания значения по умолчанию (а не когда создаётся таблица). Например, столбцу timestamp в качестве значения по умолчания часто присваивается CURRENT_TIMESTAMP, чтобы в момент добавления строки в нём оказалось текущее время.

В отличие от некоторых других СУБД, в PostgreSQL нет столбцов со свойством auto_increment. Вместо этого в постгресе используются последовательности (sequences).	

Таким кодом создадим таблицу:

CREATE SEQUENCE user_ids;
CREATE TABLE users (
  id INTEGER PRIMARY KEY DEFAULT NEXTVAL('user_ids'),
  email text DEFAULT 'Frodo.com',
  login text,
  pass text);
 
INSERT INTO users(login,pass) VALUES
('Vasa','12345'),
('Petay','12345'),
('Tany','qwe'),
('Igor','123q');

id	email	login	pass
1	Frodo.com	Vasa	12345
2	Frodo.com	Petay	12345
3	Frodo.com	Tany	qwe
4	Frodo.com	Igor	123q

Тут ид автонумеруется за счет последовательности.

CREATE SEQUENCE — создать генератор последовательности.
CREATE [ TEMPORARY | TEMP ] SEQUENCE [ IF NOT EXISTS ] имя [ INCREMENT [ BY ] шаг ]
    [ MINVALUE мин_значение | NO MINVALUE ] [ MAXVALUE макс_значение | NO MAXVALUE ]
    [ START [ WITH ] начало ] [ CACHE кеш ] [ [ NO ] CYCLE ]
    [ OWNED BY { имя_таблицы.имя_столбца | NONE } ]

TEMPORARY или TEMP - Если указано, объект последовательности создаётся только для данного сеанса и автоматически удаляется при завершении сеанса. 
IF NOT EXISTS - Не считать ошибкой, если отношение с таким именем уже существует.
шаг - Необязательное предложение INCREMENT BY шаг определяет, какое число будет добавляться к текущему значению последовательности для получения нового значения. С положительным шагом последовательность будет возрастающей, а с отрицательным — убывающей. Значение по умолчанию: 1.
начало - Необязательное предложение START WITH начало позволяет запустить последовательность с любого значения. По умолчанию началом считается мин_значение для возрастающих последовательностей и макс_значение для убывающих.
OWNED BY имя_таблицы.имя_столбца - Предложение OWNED BY позволяет связать последовательность с определённым столбцом таблицы так, чтобы при удалении этого столбца (или всей таблицы) последовательность удалялась автоматически.

Ид начинается с 104:
CREATE SEQUENCE user_ids START 104;
Получим: 104 105 106 107

Последовательность это отдельная таблица с полями:
sequence_name	last_value	start_value	increment_by	max_value	min_value	cache_value	log_cnt	is_cycled	is_called
К ней можно запросом обратиться:
SELECT * FROM name;
И таким образом можно получить последнее значение:
	SELECT last_value FROM task_id;
поле last_value последовательности будет содержать последнее значение, выделенное для какого-либо сеанса. (Конечно, ко времени вывода это значение может стать неактуальным, если другие сеансы активно вызывают nextval.)


Сложение строк в запросе по умолчанию:
id text PRIMARY KEY DEFAULT 'Hellow' || NEXTVAL('user_ids')|| 'World',
Получим: Hellow300World Hellow301World Hellow302World Hellow303World.
}

В postgresql есть разные строковые функции{
id integer DEFAULT length('jose') - 	Количество символов в заданной строке - по умолчанию каждый ид будет равен 4.
В postgresql есть куча разных строковых функций, стандартных для std с++ и str python - upper(string), substring(string [from int] [for int]), position(substring in string), lower(string),substring(string from pattern)...
}

Попробовать настроить запросы - логирование запросов{
В unix конфигурационные файлы лежат в папке: /usr/local/pgsql/data.
postgresql.conf - основной конфигурационный файл
pg_hba.conf - в этом файле описываются клиентские компьютеры сети, с которых разрешен доступ к серверу, а также методы идентификации клиентов
pg_ident.conf - этот файл используется при установке способа идентификации клиентов через ident сервер


Ротация логов{
Ротация логов — это процесс архивирования логов, удаление старых логов и все из этого вытекающее. Оно нужно для того, чтобы внезапно у вас не забилось все место на HDD/SSD различными логами, ну, а так же для того, чтобы не было слишком много одинаковых и очень больших лог-файлов.
При ротации логов возможно:
	Файл журнала архивируется и сохраняется под именем log.log.0
	Более старые логи переименовываются (log, log,0 в log.log.1 и т.д.)
	Самые старые логи удаляются
	Очищается «главный» файл лога
	Перезапускается демон пишуший логи если это необходимо	
}
	
	logging_collector = on	
После этого в папке $PGDATA появится каталог pg_log, где будут находиться ваши логи.
Некоторые настройки логов{
производить ротацию логов спустя 1 день:
	log_rotation_age = 1d
производить ротацию логово, как только размер файла превысит 10 Mb:		
	log_rotation_size = 10MB
перезаписывать логи вместо добавления новых:
	log_truncate_on_rotation = on
Включает протоколирование завершения сеанса. В журнал выводится примерно та же информация, что и с log_connections, плюс длительность сеанс:
	log_disconnections = on
Настройка логирования: log_statement = 'mod'
	ddl — логирует изменения схемы базы данных
	mod — тоже, что ddl + операции модификации данных над строками в таблице
	all — тоже, что mod + все select запросы к базе
Настройка формата лога: log_line_prefix = '%t &lt;%d %u %r&gt; %%'
	t — это timestamp
	d — имя базы данных
	u — пользователь
	r — удаленный хост и порт
	% — символ процента
Логировать запросы, чье время выполнения превышает:
	log_min_duration_statement = 2000 # 2 секунды
	
	log_directory = 'pg_log' # директория - куда писать логи, может будь абсолютной или релятивной относительно PGDATA
	log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'	# шаблон имени лог файла.
}

Попробовать прописать в настройках{
	log_connections = on
	log_disconnections = on
	log_statement = 'all'
}

}

Индексы{
На таблицу можно создать уникальный индекс по полям. Но если поле равно null, индекс падает. одно null!=null другому.
Есть таблица test_func_index и уникальный индекс по полям name, cdate
CREATE TABLE test_func_index(
  id serial PRIMARY KEY,
  name varchar,
  cdate date
);

CREATE UNIQUE INDEX i_test_func_index_unique
  ON test_func_index
  USING btree(name, cdate);
Заполним ей:
denis=# INSERT INTO test_func_index(name, cdate) VALUES('name1', '2012-01-01');
insert 0 1
denis=# INSERT INTO test_func_index(name, cdate) VALUES('name1', '2012-01-02');
insert 0 1
denis=# INSERT INTO test_func_index(name, cdate) VALUES('name1', '2012-01-03');
insert 0 1
denis=# INSERT INTO test_func_index(name, cdate) VALUES('name1', null);
insert 0 1
Индекс работает:
denis=# INSERT INTO test_func_index(name, cdate) VALUES('name1', '2012-01-03');
ERROR:  duplicate key value violates unique constraint "i_test_func_index_unique"
DETAIL:  key (name, cdate)=(name1, 2012-01-03) already exists.
с NULL'евыми значениями. Индекс не работает:
denis=# INSERT INTO test_func_index(name, cdate) VALUES('name1', null);
insert 0 1

Для этого можно сделать условное выражение:
CREATE UNIQUE INDEX i_test_func_index_func_unique
  ON test_func_index
  USING btree(COALESCE(name, ''), COALESCE(cdate, 'infinity'));  
}

Перечисления ENUM{
postgresql поддерживает перечисления:
CREATE TYPE days AS ENUM ('Monday', 'Tuesday', 'Wednesday', 'Thursday',
 'Friday', 'Saturday','Sunday');
Получить все значения, можно довольно странным запросом:
select t.typname, e.enumlabel 
 from pg_type t, pg_enum e 
 where t.oid = e.enumtypid and typname = 'days';
Как работает не понял. но просто выбрать все из days нельзя.
Получаю все значения перечисления:
select  e.enumlabel 
from pg_type t,pg_enum e
where t.oid = e.enumtypid and t.typname = 'days';
У перечисления проблема с сравнением. Сравнить значения нельзя. some_table.some_col!=some_enum.red; Попробовать в крайнем случае что-то вроде:
WHERE person.current_mood::text = holidays.happiness::text;
Перечисления поддерживают функции:
//CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');
//Функция	Описание	Пример	Результат примера
enum_first(anyenum)	Возвращает первое значение заданного перечисления	enum_first(null::rainbow)	red

enum_last(anyenum)	Возвращает последнее значение заданного перечисления	enum_last(null::rainbow)	purple

enum_range(anyenum)	Возвращает все значения заданного перечисления в упорядоченном массиве	enum_range(null::rainbow)	{red,orange,yellow,green,blue,purple}

enum_range(anyenum, anyenum) Возвращает набор значений, лежащих между двумя заданными, в виде упорядоченного массива. Эти значения должны принадлежать одному перечислению. Если первый параметр равен NULL, функция возвращает первое значение перечисления, а если NULL второй — последнее:
	enum_range('orange'::rainbow, 'green'::rainbow) - {orange,yellow,green}
	enum_range(NULL, 'green'::rainbow) 	{red,orange,yellow,green}
	enum_range('orange'::rainbow, NULL) - {orange,yellow,green,blue,purple}
	
Select * from Question q where q._type=enum_first(null::days);
select enum_range(null::days);
}

Самонисные запросообразные Функции возвращающие результат{
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS 
'    SELECT x + y;' 
LANGUAGE SQL;
Такая функция работает.
CREATE FUNCTION isExist(y integer) RETURNS text AS 
'    SELECT name FROM task where task.id=y' 
LANGUAGE SQL;
Такая выдаст текстовое имя:
Строка: 8	Alone	Third	(null)
Select isExist(8); //isexist Third
Создадим такой запрос:
Select EXISTS(select 1 from task where id=1);
И переделаем его в функцию:
CREATE FUNCTION isExist(y integer) RETURNS boolean AS 
'    Select EXISTS(SELECT name FROM task where task.id=y)' 
LANGUAGE SQL;
Можем теперь:
SELECT isExist(12);
}

Небольшой пример моих таблиц напоминалки{
/*Объявления необходимых перечислений*/
CREATE TYPE days AS ENUM ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday','Sunday');
CREATE TYPE type_task AS ENUM ('EveryWeek', 'Alone');
/*Автонумерация для заданий*/
CREATE SEQUENCE task_id;
/*Объект Задача*/
CREATE TABLE task(
	id INTEGER PRIMARY KEY DEFAULT NEXTVAL('task_id'),
	_type type_task NOT NULL,
	name TEXT NOT NULL,
	description text
);
/*Индекс для заданий*/
CREATE UNIQUE INDEX i_task_index_unique
	ON task
	USING btree(name, _type);
/*Функции*/
CREATE FUNCTION isEveryWeek(y integer) RETURNS boolean AS 
'    Select EXISTS(SELECT t.name FROM task t where t.id=y and t._type=''EveryWeek'')' 
LANGUAGE SQL;
/*Еженедельные задания*/
CREATE TABLE connect_every_week(
	_task INTEGER REFERENCES task(id),
	_date days NOT NULL,
	CHECK (isEveryWeek(_task))
);
/*Индекс для ежедневных заданий*/
CREATE UNIQUE INDEX i_connect_every_week_index_unique
	ON connect_every_week
	USING btree(_task, _date);
/*Разовые задания*/
CREATE TABLE connect_alone_task(
	_task INTEGER REFERENCES task(id),
	_date timestamp NOT NULL,
	CHECK (NOT isEveryWeek(_task))
);
/*Просто наполняю таблицу тестовыми данными*/
INSERT INTO task(_type,name,description) VALUES
('EveryWeek','run away','need fast run'),
('EveryWeek','sleep','sleep all day'),
('Alone','eat','eat something'),
('EveryWeek','dance','dance on table'),
('Alone','drink','drink milk');

/*Запрос:*/
SELECT * FROM Task;
--INSERT INTO connect_alone_task(_task,_date) VALUES (1,'2018-07-11 7:45');
--INSERT INTO connect_alone_task(_task,_date) VALUES (2,'2018-07-12 7:45');
INSERT INTO connect_alone_task(_task,_date) VALUES (3,'2018-07-13 7:45');
--INSERT INTO connect_alone_task(_task,_date) VALUES (4,'2018-07-14 7:45');
INSERT INTO connect_alone_task(_task,_date) VALUES (5,'2018-07-15 7:45');
select * from connect_alone_task;
INSERT INTO connect_every_week(_task,_date) VALUES (1,'Monday');
INSERT INTO connect_every_week(_task,_date) VALUES (2,'Tuesday');
--INSERT INTO connect_every_week(_task,_date) VALUES (3,'Wednesday');
INSERT INTO connect_every_week(_task,_date) VALUES (4,'Thursday');
--INSERT INTO connect_every_week(_task,_date) VALUES (5,'Friday');
select * from connect_every_week;
}

WITH /*аналог вложенного запроса типо вт*/ Common Table Expressions {
	WITH cte_name (column_list) AS
    (anchor_member
     UNION ALL
     recursive_member)
     outer_query
///////////////////////
SELECT SalesOrderID
    FROM Sales.SalesOrderHeader
    WHERE TotalDue > (SELECT AVG(TotalDue)
                      FROM Sales.SalesOrderHeader
                      WHERE YEAR(OrderDate) = '2005')
        AND Freight > (SELECT AVG(TotalDue)
                       FROM Sales.SalesOrderHeader
                       WHERE YEAR(OrderDate) = '2005')/2.5;
//Тут по сути одна и та же таблица используется два раза. Ей можно вынести:
WITH price_calc(year_2005) AS
    (SELECT AVG(TotalDue)
        FROM Sales.SalesOrderHeader
        WHERE YEAR(OrderDate) = '2005')
    SELECT SalesOrderID
        FROM Sales.SalesOrderHeader
        WHERE TotalDue > (SELECT year_2005 FROM price_calc)
            AND Freight > (SELECT year_2005 FROM price_calc)/2.5;
//И можем использовать.
Параметр cte_name представляет имя OTB, которое определяет результирующую таблицу, 
Параметр column_list - список столбцов табличного выражения. (В примере выше OTB называется price_calc и имеет один столбец - year_2005.)
Параметр inner_query представляет инструкцию SELECT, которая определяет результирующий набор соответствующего табличного выражения. 
После этого определенное табличное выражение можно использовать во внешнем запросе outer_query.
//Работает, проверил:
with rty(l_r) as (select Min(ram) from pc )
SELECT l_r FROM rty
}

CREATE TEMP TABLE my_fist_temp_table(fields_list)
INSERT INTO my_fist_temp_table (fields_list) SELECT fields_list FROM table_src

UNION [ALL] (объединение)
INTERSECT [ALL] (пересечение)
EXCEPT [ALL] (разность)
SOME или ANY. Если хотя бы для одного значения V, получаемого из подзапроса, результат операции "<значение выражения> <оператор сравнения> V" равняется TRUE, то предикат ANY также равняется TRUE.
ALL.значение предиката ALL будет истинным, если для всех значений V, получаемых из подзапроса, предикат "<значение выражения> <оператор сравнения> V" дает TRUE.
WHERE type = 'pc' AND NOT model = ANY (SELECT model FROM PC);

Соединение может быть либо внутренним (INNER), либо одним из внешних (OUTER).
Служебные слова INNER и OUTER можно опускать, поскольку внешнее соединение однозначно определяется его типом — LEFT (левое), RIGHT (правое) или FULL (полное), а просто JOIN будет означать внутреннее соединение.

INNER JOIN или просто JOIN : попадут только те соединения строк двух таблиц, для которых значение предиката равно TRUE. 
LEFT JOIN означает, что помимо строк, для которых выполняется условие предиката, в результирующий набор попадут все остальные строки из первой таблицы (левой). При этом отсутствующие значения столбцов из правой таблицы будут заменены NULL-значениями.
При полном соединении (FULL JOIN) в результирующую таблицу попадут не только те строки, которые имеют одинаковые значения в сопоставляемых столбцах, но и все остальные строки исходных таблиц, не имеющие соответствующих значений в другой таблице. В этих строках все столбцы той таблицы, в которой не было найдено соответствия, заполняются NULL-значениями. То есть полное соединение представляет собой комбинацию левого и правого внешних соединений. Каждая строка одной таблицы соединяется с каждой строкой другой таблицы по выбранному условию. Могут быть дубли.

Полное соединение может находиться в том же месте, где м объединить. - сверху вложенный запрос, снизу вложенный запрос, между ними соединение, а под вторым запросом условие соединения.
}

Формы для ввода значений автоматические (Функции для вызова диалога ввода данных){
По умолчанию в 1С есть несколько форм, в которых можно ввести значение:
	ПоказатьВводЗначения(<ОписаниеОповещенияОЗавершении>, <Значение>, <Подсказка>, <Тип>) 
	ПоказатьВводДаты(<ОписаниеОповещенияОЗавершении>, <Дата>, <Подсказка>, <ЧастьДаты>) 
	ПоказатьВводЧисла(<ОписаниеОповещенияОЗавершении>, <Число>, <Подсказка>, <Длина>, <Точность>) 
}

Проблема последней копейки{
Возникает проблема с копейками. Например, проблема последней копейки возникнет при попытке продать 15 товаров за 100 партиями по 5 штук:
5/15*100=33.33333333
5/15*100=33.33333333
5/15*100=33.33333333
остается копейка. В последнем случае надо списать 33.34 а не 33.33. Округление не помогает, так как 33.3333334 округляется в 33.33, никак 4 в плюс не округлиться, иногда 4 иногда 7 может быть например 66.666667. 

ПРОБЛЕМА ИЗ ЗА ЗАПИСИ В ПЕРЕМЕННУЮ. Нельзя записывать в переменную, нужно сразу в регистр.
движение.Себестоимость=Списать/ВыборкаПартия.КоличествоОстаток* ВыборкаПартия.Себестоимость;
А цену можно так записать:
Если ОсталосьСписать<=ВыборкаПартия.КоличествоОстаток тогда
	Движение.Цена=ВыборкаНоменклатура.Цена;
	Для каждого кол_во из Массив цикл
		Движение.Цена=Движение.Цена-(кол_во/МасСписать*ВыборкаНоменклатура.Цена);		
	КонецЦикла;
иначе
	Движение.Цена=Списать/МасСписать*ВыборкаНоменклатура.Цена;
КонецЕсли;
Массив.Добавить(Списать);
И проблема решается.

}

Методики проведения{
Я делаю отдельный запрос, который проверяет, если из остатка вычесть проданное и это меньше нуля, тогда отказ.
А у 1С есть две методики: старая и новая.
В "старой" методике остатки контролируются ДО записи движений в регистры.
В "новой" методике – контроль происходит ПОСЛЕ записи движений, то есть постфактум.
Старая:
	1-Запросом получаются остатки товаров и данные документа 
	2-В цикле выполняется контроль достаточности товаров 
	3-Если товаров недостаточно, то документ не проводится 
	4-Если товаров достаточно – выполняются движения-расход
Пример кода{
Процедура ОбработкаПроведения(Отказ, РежимПроведения)
//  1. Очистка старых движений регистра
Движения.СвободныеОстатки.Очистить();     
Движения.СвободныеОстатки.Записывать = Истина;
Движения.Записать();
//  2. Получение запросом данных документа и остатков регистра
Запрос = Новый Запрос;
Запрос.Текст =
    "ВЫБРАТЬ
    |   Товары.Номенклатура КАК Номенклатура,
    |   СУММА(Товары.Количество) КАК Количество
    |ПОМЕСТИТЬ Товары
    |ИЗ
    |   Документ.РеализацияТоваровУслуг.Товары КАК Товары
    |ГДЕ
    |   Товары.Ссылка = &Ссылка
    |
    |СГРУППИРОВАТЬ ПО
    |   Товары.Номенклатура
    |
    |ИНДЕКСИРОВАТЬ ПО
    |   Номенклатура
    |;
    |
    |////////////////////////////////////////////////////////////////////////////////
    |ВЫБРАТЬ
    |   Товары.Номенклатура КАК Номенклатура,
    |   ПРЕДСТАВЛЕНИЕССЫЛКИ(Товары.Номенклатура) КАК НоменклатураПредставление,
    |   Товары.Количество КАК Количество,
    |   ЕСТЬNULL(Остатки.КоличествоОстаток, 0) КАК Остаток
    |ИЗ
    |   Товары КАК Товары
    |
  ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления.СвободныеОстатки.Остатки(
    |	&МоментВремени,
    |	Номенклатура В
    |		(ВЫБРАТЬ Товары.Номенклатура КАК Номенклатура ИЗ Товары КАК Товары)) КАК Остатки
    |	ПО Товары.Номенклатура = Остатки.Номенклатура";
Запрос.УстановитьПараметр("Ссылка", Ссылка);
Запрос.УстановитьПараметр("МоментВремени", МоментВремени());
РезультатЗапроса = Запрос.Выполнить();
    //  3. Обход результатов запроса
ВыборкаТовары = РезультатЗапроса.Выбрать();
    Пока ВыборкаТовары.Следующий() Цикл
		//  4. Проверка на достаточность товаров
		Дефицит = ВыборкаТовары.Количество - ВыборкаТовары.Остаток;
	Если Дефицит>0 Тогда
		Отказ = Истина;
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Товара "+ВыборкаТовары.НоменклатураПредставление+" недостаточно в количестве "+Дефицит+" шт.";
		Сообщение.Сообщить();
	КонецЕсли;
	
  //  5. Переход в начало цикла, если были ошибки
	Если Отказ Тогда
		Продолжить;
	КонецЕсли;

	//  6. Выполнение движений в регистры
	Движение = Движения.СвободныеОстатки.ДобавитьРасход();
    Движение.Период = Дата;
    Движение.Номенклатура = ВыборкаТовары.Номенклатура;
    Движение.Количество = ВыборкаТовары.Количество;
КонецЦикла;
    //  7. Установка флага записи движений в конце транзакции
Движения.СвободныеОстатки.Записывать = Истина;
КонецПроцедуры

}

Преимущества новой методики:
	1-Нет необходимости очищать старые движения документа. По сути это операция записи в БД пустого набора движений и удаление существующих движений – это довольно ресурсоемкие операции.
	2-Запрос, получающий данные по отрицательным остаткам, обращается только к одной таблице – нет необходимости делать левое соединение с данными документа и применять функцию «ЕСТЬNULL()».
	При нормальном течении бизнес-процессов пользователь указывает количество, не превышающее остаток на складе. Тогда проведение будет максимально быстрым.

Новая методика может использоваться только в том случае, если для проведения документа есть все необходимые данные в самом документе. То есть для получения данных не нужно обращаться к регистрам, по которым производится контроль остатков. Так, например, если в регистре «Свободные остатки» учитывалась бы и сумма, то пришлось бы использовать старую методику контроля.

Критерий применимости – если для формирования движений нет необходимости обращаться к данным контролируемого регистра, можно использовать новую методику.

Блокировку по старой методике надо ставить:
	1-После помещения списка товаров в виртуальную таблицу
	2-тут блокировка
	3-перед получением остатков.
Пример с помещением в ИсточникДанных РезультатЗапроса{
    //  I. Инициализация менеджера временных таблиц     Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
Запрос.Текст =
    "ВЫБРАТЬ         
	|   РеализацияТовары.Номенклатура КАК Номенклатура,
    |   СУММА(РеализацияТовары.Количество) КАК Количество,
    |   МИНИМУМ(РеализацияТовары.НомерСтроки) КАК НомерСтроки
    |ПОМЕСТИТЬ ТоварыДокумента
    |ИЗ
    |   Документ.РеализацияТоваровУслуг.Товары КАК РеализацияТовары
    |ГДЕ
    |   РеализацияТовары.Ссылка = &Ссылка
    |
    |СГРУППИРОВАТЬ ПО
    |   РеализацияТовары.Номенклатура
    |
    |ИНДЕКСИРОВАТЬ ПО
    |   Номенклатура
    |;
    |
    |////////////////////////////////////////////////////////////////////////////////
    |ВЫБРАТЬ
    |   ТоварыДокумента.Номенклатура КАК Номенклатура
    |ИЗ
    |   ТоварыДокумента КАК ТоварыДокумента";

	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	РезультатЗапроса = Запрос.Выполнить();
    //  II. Установка блокировки
Блокировка = Новый БлокировкаДанных;
ЭлементБлокировки = Блокировка.Добавить("РегистрНакопления.ПартииТоваров");
ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
ЭлементБлокировки.ИсточникДанных = РезультатЗапроса;
ЭлементБлокировки.ИспользоватьИзИсточникаДанных("Номенклатура", "Номенклатура");
Блокировка.Заблокировать();
    //  III. Выполняем запрос к остаткам партий
  Запрос.Текст =
    "ВЫБРАТЬ
    |   ТоварыДокумента.Номенклатура КАК Номенклатура,
    |   ТоварыДокумента.Количество КАК Количество,
    |   ТоварыДокумента.НомерСтроки КАК НомерСтроки,
    |   ЕСТЬNULL(Остатки.КоличествоОстаток, 0) КАК КоличествоОстаток,
    |   ЕСТЬNULL(Остатки.СуммаОстаток, 0) КАК СуммаОстаток,
    |   Остатки.Партия КАК Партия
    |ИЗ
    |   ТоварыДокумента КАК ТоварыДокумента
    |
  ЛЕВОЕ СОЕДИНЕНИЕ РегистрНакопления.ПартииТоваров.Остатки(
    |	&МоментВремени,
    |	Номенклатура В
    |	(ВЫБРАТЬ
    |	Т.Номенклатура КАК Номенклатура ИЗ
    | ТоварыДокумента КАК Т)) КАК Остатки
    |  ПО ТоварыДокумента.Номенклатура = Остатки.Номенклатура
    |
    |УПОРЯДОЧИТЬ ПО
    |   Партия
    |ИТОГИ
    |   МАКСИМУМ(Количество),
    |   СУММА(КоличествоОстаток)
    |ПО
    |   НомерСтроки         
	|АВТОУПОРЯДОЧИВАНИЕ";

}

}


План:
	+ Решение оперативных задач
	- решение бухгалтерских задач
	- решение расчетных задач (сложные переодические расчеты)
	- Бизнес процессы
	- управляемые формы.
	
	2- ОпределитьОптимальныеАгрегаты() и еще куча действий с агрегатами. Зачем??? Много непонятного про агрегаты.
	5- стандарты:  Система стандартов и методик разработки конфигураций для платформы 1С:Предприятие 8 (	https://its.1c.ru/db/v8std#content:2149184105:hdoc	)(выполнения системы стандартов рекомендованных 1С)
	6- выписать себе sql которым формируются документы, справочник, регистры, пвх, зазезть в табличную часть и составной реквизит.
	7- посмотреть оборотный регистр, ВОЗМОЖНО в системной таблице для оборотного резистра система складывает обороты за месяц. В остатках в итогах все суммируется а тут каждый месяц. Узнать физическую разницу между оборотами и остатками.
	9- в методической поддержке есть крайне интересный раздел: "Разработчикам" -> "Методические рекомендации" -> "Прикладные объекты". Там много интересных моментов про регистры, документы, проведении, ручное изменение.
	10- посмотреть что такое журнал документов. Возможно это не типо динамический список для нескольких документов, а отдельная таблица со всеми реквизитами документов, которая нужна для создания общего индекса для документов разного вида. Говорят все данные будут в ней дублироваться. Проще запрос сделать с соединением. Если не нужна сортировка, то его лучше и не трогать.
	11-погуглить про белоусова из 1С.
	12-все таки посмотреть физически про оборотный регистр. Остатки понял, и что там все в ноль должно выйти, а оборотный слабо понимаю.