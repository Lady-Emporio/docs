Библиотеки подключаются к основной программе во время линковки. По способу компоновки библиотеки подразделяют на архивы (статические библиотеки, static libraries) и совместно используемые (динамические библиотеки, shared libraries).
В Linux статические библиотеки обычно имеют расширение .a (Archive), а совместно используемые библиотеки имеют расширение .so (Shared Object). 

команда ar создает статическую библиотеку (архив). В нашем случае два объектных файла объединяются в один файл libworld.a. В Linux практически все библиотеки имеют префикс lib.

Опция -L указывает линковщику, где ему искать библиотеку. В случае, если библиотека располагается в каталоге /lib или /usr/lib, то вопрос отпадает сам собой и опция -L не требуется. В нашем случае библиотека находится в репозитории (в текущем каталоге). По умолчанию линковщик не просматривает текущий каталог в поиске библиотеки, поэтому опция -L. (точка означает текущий каталог) необходима.

 Опция -l, переданная компилятору, обрабатывается и посылается линковщику для того, чтобы тот подключил к бинарнику библиотеку. Как вы уже заметили, у имени библиотеки "обрублены" префикс и суффикс. Это делается для того, чтобы создать "видимое безразличие" между статическими и динамическими библиотеками. Но об этом речь пойдет в других главах книги. Сейчас важно знать лишь то, что и библиотека libfoo.so и библиотека libfoo.a подключаются к проекту опцией -lfoo. В нашем случае libworld.a "урезалось" до -lworld.
 
Правило для сборки binary теперь содержит пугающую опцию -Wl,-rpath,. Ничего страшного тут нет. Как уже неоднократно говорилось, компилятор gcc сам вызывает линковщик ld, когда это надо и передает ему нужные параметры сборки, избавляя нас от ненужной платформенно-зависимой волокиты. Но иногда мы все-таки должны вмешаться в этот процесс и передать линковщику "свою" опцию. Для этого используется опция компилятора -Wl,option,optargs,... Расшифровываю: передать линковщику (-Wl) опцию option с аргументами optargs. В нашем случае мы передаем линковщику опцию -rpath с аргументом . (точка, текущий каталог). Возникает вопрос: что означает опция -rpath? Как уже говорилось, линковщик ищет библиотеки в определенных местах; обычно это каталоги /lib и /usr/lib, иногда /usr/local/lib. Опция -rpath просто добавляет к этому списку еще один каталог. В нашем случае это текущий каталог. Без указания опции -rpath, линковщик "молча" соберет программу, но при запуске нас будет ждать сюрприз: программа не запустится из-за отсутствия библиотеки. Попробуйте убрать опцию -Wl,-rpath,. из Makefile и пересоберите проект. При попытке запуска программа binary завершится с кодом возврата 127 (о кодах возврата будет рассказано в последующих главах). То же самое произойдет, если вызвать программу из другого каталога. Верните обратно -Wl,-rpath,., пересоберите проект, поднимитесь на уровень выше командой cd .. и попробуйте запустить бинарник командой world/binary. Ничего не получится, поскольку в новом текущем каталоге библиотеки нет.

Статические библиотеки создаются при помощи архиватора ar, а совместно используемые - при помощи gcc с опцией -shared.

Опциии -fPIC (-fpic) при компиляции h_world.c и g_world.c. Эта опция сообщает компилятору, что объектные файлы, полученные в результате компиляции должны содержать позиционно-независимый код (PIC - Position Independent Code), который используется в динамических библиотеках. В таком коде используются не фиксированные позиции (адреса), а плавающие, благодаря чему код из библиотеки имеет возможность подключаться к программе в момент запуска.
/*Рабочий пример статичной библиотеки. Как слиновалось не пойму, но работает.*/{
https://www.opennet.ru/docs/RUS/zlp/003.html

Начнем с интерфейса. Создадим файл world.h:
/* world.h */
void h_world (void);
void g_world (void);
Теперь надо реализовать серверы. Создадим файл h_world.c:
/* h_world.c */
#include <stdio.h>
#include "world.h"

void h_world (void)
{
        printf ("Hello World\n");
}
Теперь создадим файл g_world.c, содержащий реализацию функции g_world():
/* g_world.c */
#include <stdio.h>
#include "world.h"

void g_world (void)
{
        printf ("Goodbye World\n");
}
Теперь создадим файл main.c. Это клиент, который будет пользоваться услугами сервера:
/* main.c */
#include "world.h"

int main (void)
{
        h_world ();
        g_world ();
}


Теперь напишем сценарий для make. Для этого создаем Makefile:


# Makefile for World project

binary: main.o libworld.a
        gcc -o binary main.o -L. -lworld

main.o: main.c
        gcc -c main.c

libworld.a: h_world.o g_world.o
        ar cr libworld.a h_world.o g_world.o

h_world.o: h_world.c
        gcc -c h_world.c

g_world.o: g_world.c
        gcc -c g_world.c

clean:
        rm -f *.o *.a binary

Не забывайте ставить табуляции перед каждым правилом в целевых связках.
Собираем программу:

// Это тот код, который собрал. Ручками это ввел, так как make ругался на что-то.
$ make
gcc -c main.c
gcc -c h_world.c
gcc -c g_world.c
ar cr libworld.a h_world.o g_world.o
gcc -o binary main.o -L. -lworld
$

//Запуск работает
$ ./binary
Hello World
Goodbye World
$






}
Получилось скомпилировать dll:
gcc -c -DBUILD_DLL for.cpp //скомпилировать for.o
gcc -shared -o mydll.dll for.o //сделал mydll.dll

В линуксе чтобы слинковать dll нужно: -ldl.
Это для библиотеки: #include <dlfcn.h>

g++ main.cpp -std=c++11 -ldl //скомпилировалось

On Linux, compile with:
g++ -fPIC -shared for.cpp -o for.so // создал for.so
g++ main.cpp -ldl 
g++ main.cpp -ldl -o myexe //тоже самое, только создаст исполняемый файл myexe

g++ -fPIC -shared -rdynamic for.cpp -o for.so


#include <iostream>
#include <dlfcn.h> //какая то библиотека для линукса для RTLD_LAZY
int main(){
    std::cout<<"Start main"<<std::endl;
    void *handle;
    handle = dlopen ("./mydll.dll", RTLD_LAZY);
    if (!handle) {
        std::cout<<"Can`t handle dll"<<std::endl;
        return 4;
    }
    int (*add2)(int);
    add2 = (int (*) (int))dlsym(handle, "add2");
    std::cout<<add2<<std::endl;
    //std::cout<<add2(7)<<std::endl;
    
    std::cout<<"End main"<<std::endl;
}